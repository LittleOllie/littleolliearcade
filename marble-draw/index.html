<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Chainstone: The Forge</title>

  <style>
    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    :root{
      --bg1:#6de0ff; --bg2:#4c6fff;
      --panel: rgba(0,0,0,.18);
      --panel2: rgba(0,0,0,.22);
      --shadow: 0 14px 34px rgba(0,0,0,.35);
      --btnYellow:#ffdd55; --btnYellow2:#ffd22e; --btnText:#222;
      --btnShadow: 0 10px 20px rgba(0,0,0,.22);
      --text:#fff; --radius:18px; --gap:10px;
    }

    body{
      margin:0;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      background: radial-gradient(1200px 800px at 20% 10%, rgba(255,255,255,.25), transparent 55%),
                  linear-gradient(135deg, var(--bg1), var(--bg2));
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      padding: 14px;
    }

    .app{
      width:min(980px, 100%);
      display:flex;
      flex-direction:column;
      gap: 10px;
    }

    /* HEADER IMAGE - no trimming */
    .headerWrap{
      width:100%;
      background: rgba(0,0,0,.18);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 10px;
    }
    .headerImg{
      width:100%;
      height:auto;
      display:block;
      border-radius: 14px;
      background: rgba(0,0,0,.10);
    }

    .bar{
      width:100%;
      background: var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 10px;
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
    }

    .leftBtns, .rightInfo{
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      align-items:center;
    }

    .btn{
      border:0;
      padding: 10px 14px;
      border-radius: 14px;
      background: linear-gradient(var(--btnYellow), var(--btnYellow2));
      color: var(--btnText);
      font-weight: 900;
      letter-spacing:.2px;
      cursor:pointer;
      box-shadow: var(--btnShadow);
      display:flex;
      gap:8px;
      align-items:center;
      user-select:none;
      touch-action: manipulation;
    }
    .btn:active{ transform: translateY(1px); }
    .btn[disabled]{ opacity:.55; cursor:not-allowed; filter:saturate(.75); }

    /* ‚úÖ make select look like the yellow buttons */
    .selectBtn{
      appearance:none;
      -webkit-appearance:none;
      -moz-appearance:none;
      padding-right: 36px;
      position: relative;
    }
    .selectWrap{
      position: relative;
      display:inline-block;
    }
    .selectWrap:after{
      content:"‚ñæ";
      position:absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-52%);
      color: rgba(0,0,0,.55);
      font-weight: 950;
      pointer-events:none;
    }

    .pill{
      background: rgba(0,0,0,.22);
      border-radius: 999px;
      padding: 8px 12px;
      display:flex;
      gap: 10px;
      align-items:center;
      box-shadow: 0 10px 22px rgba(0,0,0,.22);
      font-weight: 800;
      white-space:nowrap;
    }
    .small{ font-weight:800; opacity:.95; font-size: 14px; }
    .muted{ opacity:.85; font-weight:800; }

    /* compact ink pill */
    .inkPill{
      display:flex;
      gap: 10px;
      align-items:center;
      min-width: 240px;
    }
    .inkMeter{
      width: 120px;
      height: 10px;
      border-radius: 999px;
      overflow:hidden;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.16);
    }
    .inkFill{
      height:100%;
      width: 100%;
      background: linear-gradient(90deg, rgba(255,255,255,.9), rgba(255,255,255,.45));
      border-radius: 999px;
    }

    .gameWrap{
      width:100%;
      background: var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 10px;
      position: relative;
    }

    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius: 16px;
      /* keep your current ‚Äúpanel‚Äù background; images get drawn inside canvas */
      background:
        radial-gradient(900px 560px at 60% 25%, rgba(255,170,0,.16), transparent 55%),
        radial-gradient(900px 560px at 20% 60%, rgba(0,0,0,.22), transparent 60%),
        linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,.35));
      touch-action:none;
    }

    .overlay{
      position:absolute;
      inset: 10px;
      border-radius: 16px;
      pointer-events:none;
    }

    .toast{
      position:absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,.35);
      padding: 10px 14px;
      border-radius: 999px;
      font-weight: 900;
      box-shadow: 0 12px 26px rgba(0,0,0,.35);
      pointer-events:none;
      opacity:0;
      transition: opacity .2s ease;
      text-align:center;
      max-width: calc(100% - 24px);
    }
    .toast.show{ opacity:1; }

    .modal{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.45);
      padding: 18px;
      z-index: 50;
    }
    .modalCard{
      width: min(560px, 100%);
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 22px;
      box-shadow: 0 22px 60px rgba(0,0,0,.55);
      padding: 16px;
      backdrop-filter: blur(10px);
    }
    .modalTitle{
      font-size: 18px;
      font-weight: 950;
      margin-bottom: 8px;
      letter-spacing:.2px;
    }
    .modalBody{
      opacity:.95;
      font-weight: 800;
      line-height: 1.35;
      margin-bottom: 12px;
      white-space: pre-line;
    }
    .stars{
      font-size: 22px;
      margin: 6px 0 10px;
    }
    .row{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    /* Powered by */
    .poweredBy{
      text-align:center;
      margin: 10px 0 0;
      opacity:.85;
      font-weight: 800;
      font-size: 13px;
    }
    .poweredBy a{
      color: rgba(255,255,255,.95);
      text-decoration: none;
      border-bottom: 1px dashed rgba(255,255,255,.45);
    }
    .poweredBy a:hover{
      opacity: 1;
    }

    @media (max-width: 560px){
      body{ padding: 10px; }
      .btn{ padding: 10px 12px; border-radius: 13px; }
      .pill{ padding: 8px 10px; }
      .inkPill{ min-width: 210px; }
      .inkMeter{ width: 95px; }
    }
  </style>
</head>

<body>
  <div class="app">

    <!-- HEADER PNG -->
    <div class="headerWrap">
      <img class="headerImg" src="header.png" alt="Chainstone: The Forge" />
    </div>

    <!-- BUTTON BAR -->
    <div class="bar">
      <div class="leftBtns">
        <!-- ‚úÖ EXACT ORDER YOU ASKED (actions): Arcade, Start, Clear, Retry -->
        <button class="btn" id="btnArcade">üïπÔ∏è Arcade</button>
        <button class="btn" id="btnStart">‚ñ∂Ô∏è Start</button>
        <button class="btn" id="btnClear">üßΩ Clear</button>
        <button class="btn" id="btnRetry" disabled>üîÅ Retry</button>

        <!-- ‚úÖ Difficulty dropdown (styled like buttons) -->
        <div class="selectWrap">
          <select class="btn selectBtn" id="difficultySelect" aria-label="Difficulty">
            <option value="Ember">üî• Ember</option>
            <option value="Heated">üî• Heated</option>
            <option value="Molten">üî• Molten</option>
          </select>
        </div>

        <!-- ‚úÖ Leaderboard button -->
        <button class="btn" id="btnLeaderboard">üèÜ Leaderboard</button>
      </div>

      <div class="rightInfo">
        <div class="pill">üó∫Ô∏è <span class="small">Level</span> <span id="levelLabel">1</span>/<span id="levelTotal">10</span></div>

        <div class="pill inkPill" title="Chalk Ink remaining">
          üñçÔ∏è <span class="small">Ink</span> <span id="inkLeft">100</span>%
          <div class="inkMeter" aria-hidden="true"><div class="inkFill" id="inkFill"></div></div>
        </div>

        <div class="pill">‚ù§Ô∏è <span class="small">Lives</span> <span id="livesLeft">5</span></div>

        <div class="pill">‚è±Ô∏è <span class="small">Run Time</span> <span id="runTime">0.0</span>s</div>
        <div class="pill">üèÅ <span class="small">Total</span> <span id="totalTime">0.0</span>s</div>
        <div class="pill">‚ú® <span class="small">Embers</span> <span id="embers">0</span></div>
      </div>
    </div>

    <!-- GAME -->
    <div class="gameWrap">
      <canvas id="cv" width="960" height="540"></canvas>

      <div class="overlay">
        <div class="toast" id="toast">Draw a chalk track, then press Start ‚ñ∂Ô∏è</div>
      </div>
    </div>

    <div class="poweredBy">
      ‚ö°Powered by <a href="#" onclick="return false;">Little Ollie Studio</a>
    </div>

  </div>

  <!-- WIN MODAL -->
  <div class="modal" id="modal">
    <div class="modalCard">
      <div class="modalTitle" id="modalTitle">Level Complete!</div>
      <div class="stars" id="modalStars">‚≠ê‚≠ê‚≠ê</div>
      <div class="modalBody" id="modalBody"></div>
      <div class="row">
        <button class="btn" id="btnNext">‚û°Ô∏è Next</button>
        <button class="btn" id="btnClose">‚úÖ Close</button>
      </div>
    </div>
  </div>

  <!-- Leaderboard modal (placeholder UI) -->
  <div class="modal" id="lbModal">
    <div class="modalCard">
      <div class="modalTitle">üèÜ Leaderboard</div>
      <div class="modalBody" id="lbBody">Top times will show here.</div>
      <div class="row">
        <button class="btn" id="lbClose">‚úÖ Close</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ============================================================
  //  CHAINSTONE: THE FORGE
  // ============================================================

  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  // UI
  const btnClear = document.getElementById("btnClear");
  const btnStart = document.getElementById("btnStart");
  const btnRetry = document.getElementById("btnRetry");

  // NEW UI
  const btnArcade = document.getElementById("btnArcade");
  const btnLeaderboard = document.getElementById("btnLeaderboard");
  const difficultySelect = document.getElementById("difficultySelect");
  const livesLeftEl = document.getElementById("livesLeft");

  const levelLabel = document.getElementById("levelLabel");
  const levelTotal = document.getElementById("levelTotal");
  const runTimeEl = document.getElementById("runTime");
  const totalTimeEl = document.getElementById("totalTime");
  const embersEl = document.getElementById("embers");

  const inkLeftEl = document.getElementById("inkLeft");
  const inkFill = document.getElementById("inkFill");
  const toast = document.getElementById("toast");

  const modal = document.getElementById("modal");
  const modalTitle = document.getElementById("modalTitle");
  const modalStars = document.getElementById("modalStars");
  const modalBody = document.getElementById("modalBody");
  const btnNext = document.getElementById("btnNext");
  const btnClose = document.getElementById("btnClose");

  // Leaderboard modal
  const lbModal = document.getElementById("lbModal");
  const lbBody = document.getElementById("lbBody");
  const lbClose = document.getElementById("lbClose");

  // Canvas scaling
  function resizeCanvasToFit() {
    const wrap = cv.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const targetW = Math.max(320, Math.floor(wrap.width * dpr));
    const targetH = Math.floor(targetW * (9/16));
    cv.width = targetW;
    cv.height = targetH;
  }
  window.addEventListener("resize", () => {
    resizeCanvasToFit();
    loadLevel(currentDifficulty, currentLevelIndex);
  });

  // Helpers
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist2 = (ax, ay, bx, by) => {
    const dx = ax - bx, dy = ay - by;
    return dx*dx + dy*dy;
  };

  function showToast(msg, ms=1400){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toast.classList.remove("show"), ms);
  }

  // ============================================================
  // BACKGROUNDS (bg1.png - bg3.png in /backgrounds folder)
  // ============================================================

  const BG_PATHS = [
    "backgrounds/bg1.png",
    "backgrounds/bg2.png",
    "backgrounds/bg3.png"
  ];

  const bgImages = BG_PATHS.map((src) => {
    const img = new Image();
    img.src = src;
    return img;
  });

  // A little transparent so your game still feels ‚Äúin the panel‚Äù
  const BG_ALPHA = 0.28;

  // Shelf/‚Äúplatform‚Äù colors per background
  const SHELF_COLORS = [
    "rgba(120, 78, 38, 0.78)",  // bg1 -> brown
    "rgba(70, 140, 235, 0.70)", // bg2 -> blue
    "rgba(255, 95, 15, 0.72)"   // bg3 -> molten lava
  ];

  function drawCoverImage(img, alpha){
    if(!img || !img.complete || !img.naturalWidth) return;

    const cw = cv.width, ch = cv.height;
    const iw = img.naturalWidth, ih = img.naturalHeight;
    const scale = Math.max(cw/iw, ch/ih);
    const dw = iw * scale, dh = ih * scale;
    const dx = (cw - dw) * 0.5;
    const dy = (ch - dh) * 0.5;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.drawImage(img, dx, dy, dw, dh);
    ctx.restore();
  }

  // ============================================================
  // DIFFICULTY TUNING (Lives + Ink)
  // ============================================================

  let currentDifficulty = "Ember";
  let currentLevelIndex = 0;

  // Lives per difficulty (as requested)
  const livesByDiff = { Ember: 5, Heated: 4, Molten: 3 };

  // Ink per difficulty (slightly less, not too harsh)
  const inkMaxByDiff = { Ember: 1200, Heated: 1100, Molten: 1020 };

  function setDifficulty(diff){
    currentDifficulty = diff;
    difficultySelect.value = diff;

    world.inkMax = inkMaxByDiff[diff] ?? 1200;
    world.livesMax = livesByDiff[diff] ?? 5;
    world.lives = world.livesMax;
    updateLivesUI();

    world.totalTime = 0;
    currentLevelIndex = 0;
    loadLevel(currentDifficulty, currentLevelIndex);

    showToast(`Difficulty set: ${currentDifficulty}`, 1200);
  }

  // ============================================================
  // LEVEL DATA
  // ============================================================

  function L(start, goal, solids, embers, starTimes){
    return { start, goal, solids, embers, starTimes };
  }

  const levelsByDiff = {
    Ember: [
      L([0.12,0.28],[0.86,0.72],
        [
          [[0.05,0.10],[0.95,0.10]], [[0.95,0.10],[0.95,0.90]],
          [[0.95,0.90],[0.05,0.90]], [[0.05,0.90],[0.05,0.10]],
          [[0.10,0.30],[0.22,0.36]],
          [[0.42,0.48],[0.58,0.44]],
          [[0.58,0.44],[0.70,0.50]],
        ],
        [[0.36,0.40],[0.60,0.60],[0.74,0.55]],
        [6.5, 9.5, 13.0]
      ),
      L([0.12,0.24],[0.86,0.78],
        [
          [[0.05,0.10],[0.95,0.10]], [[0.95,0.10],[0.95,0.90]],
          [[0.95,0.90],[0.05,0.90]], [[0.05,0.90],[0.05,0.10]],
          [[0.10,0.26],[0.26,0.34]],
          [[0.35,0.62],[0.55,0.56]],
          [[0.55,0.56],[0.74,0.64]],
          [[0.36,0.30],[0.48,0.36]],
        ],
        [[0.32,0.44],[0.52,0.70],[0.70,0.66]],
        [7.0, 10.5, 14.0]
      ),
      L([0.12,0.30],[0.86,0.70],
        [
          [[0.05,0.10],[0.95,0.10]], [[0.95,0.10],[0.95,0.90]],
          [[0.95,0.90],[0.05,0.90]], [[0.05,0.90],[0.05,0.10]],
          [[0.10,0.32],[0.24,0.38]],
          [[0.30,0.52],[0.44,0.46]],
          [[0.44,0.46],[0.58,0.54]],
          [[0.60,0.40],[0.72,0.46]],
          [[0.34,0.76],[0.58,0.70]],
        ],
        [[0.28,0.44],[0.50,0.52],[0.66,0.48]],
        [7.0, 10.5, 14.5]
      ),
      L([0.14,0.26],[0.84,0.74],
        [
          [[0.05,0.10],[0.95,0.10]], [[0.95,0.10],[0.95,0.90]],
          [[0.95,0.90],[0.05,0.90]], [[0.05,0.90],[0.05,0.10]],
          [[0.12,0.28],[0.26,0.34]],
          [[0.30,0.40],[0.44,0.46]],
          [[0.44,0.46],[0.58,0.42]],
          [[0.62,0.62],[0.78,0.56]],
          [[0.26,0.66],[0.36,0.62]],
        ],
        [[0.34,0.54],[0.56,0.58],[0.74,0.62]],
        [7.2, 10.8, 15.0]
      ),
      L([0.14,0.30],[0.84,0.70],
        [
          [[0.05,0.10],[0.95,0.10]], [[0.95,0.10],[0.95,0.90]],
          [[0.95,0.90],[0.05,0.90]], [[0.05,0.90],[0.05,0.10]],
          [[0.12,0.32],[0.26,0.38]],
          [[0.30,0.56],[0.50,0.50]],
          [[0.50,0.50],[0.70,0.58]],
          [[0.28,0.74],[0.52,0.68]],
        ],
        [[0.36,0.48],[0.54,0.62],[0.72,0.56]],
        [7.4, 11.0, 15.5]
      ),
      L([0.14,0.26],[0.84,0.78],
        [
          [[0.05,0.10],[0.95,0.10]], [[0.95,0.10],[0.95,0.90]],
          [[0.95,0.90],[0.05,0.90]], [[0.05,0.90],[0.05,0.10]],
          [[0.12,0.28],[0.26,0.34]],
          [[0.34,0.62],[0.56,0.54]],
          [[0.56,0.54],[0.78,0.62]],
          [[0.36,0.42],[0.50,0.46]],
        ],
        [[0.30,0.46],[0.52,0.70],[0.74,0.66]],
        [7.6, 11.4, 16.0]
      ),
      L([0.14,0.30],[0.84,0.74],
        [
          [[0.05,0.10],[0.95,0.10]], [[0.95,0.10],[0.95,0.90]],
          [[0.95,0.90],[0.05,0.90]], [[0.05,0.90],[0.05,0.10]],
          [[0.12,0.32],[0.26,0.38]],
          [[0.34,0.50],[0.50,0.44]],
          [[0.52,0.70],[0.72,0.62]],
          [[0.28,0.78],[0.54,0.70]],
        ],
        [[0.36,0.44],[0.54,0.58],[0.70,0.64]],
        [7.8, 11.8, 16.5]
      ),
      L([0.12,0.26],[0.86,0.72],
        [
          [[0.05,0.10],[0.95,0.10]], [[0.95,0.10],[0.95,0.90]],
          [[0.95,0.90],[0.05,0.90]], [[0.05,0.90],[0.05,0.10]],
          [[0.10,0.28],[0.26,0.36]],
          [[0.36,0.60],[0.62,0.50]],
          [[0.62,0.50],[0.78,0.58]],
          [[0.30,0.44],[0.44,0.48]],
        ],
        [[0.32,0.50],[0.58,0.62],[0.76,0.60]],
        [8.2, 12.2, 17.0]
      ),
      L([0.12,0.30],[0.86,0.70],
        [
          [[0.05,0.10],[0.95,0.10]], [[0.95,0.10],[0.95,0.90]],
          [[0.95,0.90],[0.05,0.90]], [[0.05,0.90],[0.05,0.10]],
          [[0.10,0.32],[0.26,0.40]],
          [[0.34,0.46],[0.54,0.40]],
          [[0.56,0.68],[0.80,0.62]],
          [[0.28,0.78],[0.46,0.72]],
        ],
        [[0.34,0.56],[0.54,0.62],[0.76,0.66]],
        [8.6, 12.8, 17.5]
      ),
      L([0.14,0.24],[0.84,0.78],
        [
          [[0.05,0.10],[0.95,0.10]], [[0.95,0.10],[0.95,0.90]],
          [[0.95,0.90],[0.05,0.90]], [[0.05,0.90],[0.05,0.10]],
          [[0.12,0.26],[0.28,0.34]],
          [[0.34,0.64],[0.56,0.56]],
          [[0.56,0.56],[0.78,0.66]],
          [[0.34,0.42],[0.50,0.46]],
          [[0.62,0.44],[0.76,0.40]],
        ],
        [[0.34,0.52],[0.56,0.72],[0.74,0.70]],
        [9.0, 13.2, 18.2]
      ),
    ],
    Heated: [],
    Molten: []
  };

  function cloneLevels(base, extraSolids, tighten){
    return base.map((lv) => {
      const solids = lv.solids.slice();
      extraSolids.forEach(seg => solids.push(seg));
      const starTimes = lv.starTimes.map(t => Math.max(4.5, t - tighten));
      const embers = lv.embers.map((e, k) => [
        clamp(e[0] + (k%2?0.02:-0.02), 0.12, 0.88),
        clamp(e[1] + (k%3?0.015:-0.01), 0.14, 0.86)
      ]);
      return {...lv, solids, embers, starTimes};
    });
  }

  levelsByDiff.Heated = cloneLevels(levelsByDiff.Ember, [
    [[0.46,0.34],[0.62,0.32]],
    [[0.62,0.32],[0.76,0.36]],
  ], 0.8);

  levelsByDiff.Molten = cloneLevels(levelsByDiff.Ember, [
    [[0.40,0.30],[0.56,0.28]],
    [[0.56,0.28],[0.72,0.32]],
    [[0.30,0.58],[0.44,0.52]],
  ], 1.4);

  // ============================================================
  // PHYSICS + WORLD
  // ============================================================

  const world = {
    w: () => cv.width,
    h: () => cv.height,
    ball: { x:0,y:0,vx:0,vy:0,r:14,released:false,alive:true },
    chalk: [],
    solids: [],
    goal:  { x:0,y:0,r:34 },
    start: { x:0,y:0,r:34 },
    embers: [],
    inkMax: 1200,
    ink: 1200,
    drawingLocked: false,
    rolling: false,
    runTime: 0,
    totalTime: 0,
    emberCount: 0,
    completed: false,

    // lives
    livesMax: 5,
    lives: 5,

    // background cycling
    bgIndex: 0,  // 0..2
  };

  function px([nx, ny]){ return [nx*world.w(), ny*world.h()]; }

  function updateLivesUI(){
    livesLeftEl.textContent = world.lives;
  }

  function openLeaderboard(reasonText){
    lbBody.textContent =
      (reasonText ? (reasonText + "\n\n") : "") +
      "Top times will show here.\n\n(Next: hook this up to your Firestore scores collection.)";
    lbModal.style.display = "flex";
  }

  function loadLevel(diff, idx){
    const lv = levelsByDiff[diff][idx];
    levelLabel.textContent = (idx+1);
    levelTotal.textContent = levelsByDiff[diff].length;

    // ‚úÖ cycle background each level: bg1 -> bg2 -> bg3 -> repeat
    world.bgIndex = (world.bgIndex + 1) % 3;

    world.chalk = [];
    world.ink = world.inkMax;
    world.drawingLocked = false;
    world.ball.released = false;
    world.ball.alive = true;
    world.ball.vx = 0; world.ball.vy = 0;
    world.runTime = 0;
    world.rolling = false;
    world.completed = false;

    // reset stop detection
    stopTimer = 0;
    groundTimer = 0;

    const scale = Math.min(world.w(), world.h());
    world.ball.r = Math.max(11, Math.round(scale * 0.016));
    world.goal.r = Math.max(24, Math.round(scale * 0.038));
    world.start.r = world.goal.r;

    world.solids = lv.solids.map(s => {
      const a = px(s[0]), b = px(s[1]);
      return { ax:a[0], ay:a[1], bx:b[0], by:b[1], thick: Math.max(10, Math.round(scale*0.010)) };
    });

    const s = px(lv.start), g = px(lv.goal);
    world.start.x = s[0]; world.start.y = s[1];
    world.goal.x  = g[0]; world.goal.y  = g[1];

    world.ball.x = world.start.x;
    world.ball.y = world.start.y - world.ball.r*0.2;

    world.embers = lv.embers.map(e => {
      const p = px(e);
      return { x:p[0], y:p[1], r: Math.max(10, Math.round(scale*0.012)), taken:false, timeBonus: 2.0 };
    });

    updateInkUI();
    updateTimeUI();
    updateEmbersUI();
    updateLivesUI();

    btnRetry.disabled = true;
    btnStart.disabled = false;

    showToast("Draw a chalk track, then press Start ‚ñ∂Ô∏è", 1400);
  }

  // ============================================================
  // DRAWING
  // ============================================================

  let drawing = false;
  let lastPt = null;

  function getPointer(e){
    const rect = cv.getBoundingClientRect();
    const t = (e.touches && e.touches[0]) ? e.touches[0] : e;
    const x = (t.clientX - rect.left) * (cv.width / rect.width);
    const y = (t.clientY - rect.top)  * (cv.height / rect.height);
    return {x,y};
  }

  function canSpendInk(cost){ return world.ink - cost >= 0; }

  function spendInk(cost){
    world.ink = Math.max(0, world.ink - cost);
    updateInkUI();
  }

  function addChalkSegment(a, b){
    const pad = 16;
    const ax = clamp(a.x, pad, world.w()-pad);
    const ay = clamp(a.y, pad, world.h()-pad);
    const bx = clamp(b.x, pad, world.w()-pad);
    const by = clamp(b.y, pad, world.h()-pad);

    const d = Math.sqrt(dist2(ax,ay,bx,by));
    if(d < 0.5) return;

    const cost = d * 0.9;
    if(!canSpendInk(cost)) return;

    spendInk(cost);

    const thick = Math.max(12, Math.round(Math.min(world.w(), world.h()) * 0.012));
    world.chalk.push({ ax, ay, bx, by, thick });

    if(world.chalk.length > 900) world.chalk.shift();
  }

  function pointerDown(e){
    if(world.drawingLocked) return;
    drawing = true;
    lastPt = getPointer(e);
    e.preventDefault?.();
  }
  function pointerMove(e){
    if(!drawing || world.drawingLocked) return;
    const p = getPointer(e);
    if(lastPt){
      const steps = Math.ceil(Math.sqrt(dist2(lastPt.x,lastPt.y,p.x,p.y)) / 8);
      let prev = lastPt;
      for(let i=1;i<=steps;i++){
        const t = i/steps;
        const cur = { x: prev.x + (p.x-prev.x)*t, y: prev.y + (p.y-prev.y)*t };
        addChalkSegment(prev, cur);
        prev = cur;
      }
    }
    lastPt = p;
    e.preventDefault?.();
  }
  function pointerUp(){
    drawing = false;
    lastPt = null;
  }

  cv.addEventListener("pointerdown", pointerDown);
  cv.addEventListener("pointermove", pointerMove);
  window.addEventListener("pointerup", pointerUp);

  cv.addEventListener("touchstart", (e)=>{ pointerDown(e); }, {passive:false});
  cv.addEventListener("touchmove",  (e)=>{ pointerMove(e); }, {passive:false});
  cv.addEventListener("touchend",   ()=>{ pointerUp(); }, {passive:true});

  // ============================================================
  // COLLISION
  // ============================================================

  function collideBallWithSegment(ball, seg, bounce=0.25, friction=0.985){
    const ax = seg.ax, ay = seg.ay, bx = seg.bx, by = seg.by;
    const vx = bx-ax, vy = by-ay;
    const len2 = vx*vx + vy*vy;
    if(len2 < 0.0001) return;

    const t = clamp(((ball.x-ax)*vx + (ball.y-ay)*vy) / len2, 0, 1);
    const cx = ax + t*vx, cy = ay + t*vy;
    const dx = ball.x - cx, dy = ball.y - cy;
    const r = ball.r + seg.thick*0.5;

    const d2 = dx*dx + dy*dy;
    if(d2 > r*r) return;

    const d = Math.sqrt(d2) || 0.0001;
    const nx = dx / d, ny = dy / d;

    const pen = (r - d);
    ball.x += nx * pen;
    ball.y += ny * pen;

    const vn = ball.vx*nx + ball.vy*ny;
    if(vn < 0){
      ball.vx -= (1 + bounce) * vn * nx;
      ball.vy -= (1 + bounce) * vn * ny;
      ball.vx *= friction;
      ball.vy *= friction;
    }
  }

  // ============================================================
  // LOOP
  // ============================================================

  let lastTs = performance.now();

  // ‚úÖ stop + ground detection timers
  let stopTimer = 0;
  let groundTimer = 0;

  function loseLife(reason){
    if(world.completed) return;
    if(world.lives <= 0) return;

    world.lives = Math.max(0, world.lives - 1);
    updateLivesUI();

    world.rolling = false;
    world.drawingLocked = false;

    const lv = levelsByDiff[currentDifficulty][currentLevelIndex];
    const s = px(lv.start);
    world.ball.x = s[0];
    world.ball.y = s[1] - world.ball.r*0.2;
    world.ball.vx = 0; world.ball.vy = 0;
    world.ball.released = false;
    world.ball.alive = true;

    // reset stop detection
    stopTimer = 0;
    groundTimer = 0;

    btnStart.disabled = false;
    btnRetry.disabled = false;

    if(world.lives <= 0){
      showToast("üí• Out of lives! Leaderboard time üèÜ", 1400);
      btnStart.disabled = true;
      world.drawingLocked = true;

      // ‚úÖ go straight to leaderboard when out of lives
      openLeaderboard("Out of lives. Submit your best runs here (when wired).");
      return;
    }

    showToast(reason ? `üí• ${reason} (${world.lives} left)` : `üí• Life lost! (${world.lives} left)`, 1300);
  }

  function update(dt){
    const b = world.ball;

    if(world.rolling && b.alive && !world.completed){
      world.runTime += dt;
    }

    if(b.released && b.alive && !world.completed){
      const g = 1400;
      b.vy += g * dt;

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      b.vx *= 0.999;
      b.vy *= 0.999;

      for(const s of world.solids) collideBallWithSegment(b, s, 0.15, 0.992);
      for(const s of world.chalk)  collideBallWithSegment(b, s, 0.22, 0.988);

      const pad = 10;
      if(b.x < pad){ b.x = pad; b.vx *= -0.25; }
      if(b.x > world.w()-pad){ b.x = world.w()-pad; b.vx *= -0.25; }
      if(b.y < pad){ b.y = pad; b.vy *= -0.25; }

      // ‚úÖ Fell off the map (already)
      if(b.y > world.h() + b.r*2){
        b.alive = false;
        loseLife("Fell off the map!");
      }

      // ‚úÖ NEW: If ball stops completely for a moment -> lose a life
      // (Keeps it fair: needs to be REALLY slow for a short time.)
      const speed = Math.hypot(b.vx, b.vy);
      if(world.rolling){
        if(speed < 14){
          stopTimer += dt;
          if(stopTimer > 1.15){
            b.alive = false;
            loseLife("Ball stopped!");
          }
        } else {
          stopTimer = 0;
        }

        // ‚úÖ NEW: ‚Äúfalls to the ground‚Äù (hits bottom area and settles)
        const groundY = world.h() - 6;
        if(b.y > groundY - b.r && speed < 22){
          groundTimer += dt;
          if(groundTimer > 0.45){
            b.alive = false;
            loseLife("Hit the ground!");
          }
        } else {
          groundTimer = 0;
        }
      }

      for(const em of world.embers){
        if(em.taken) continue;
        if(dist2(b.x,b.y, em.x, em.y) <= (b.r+em.r)*(b.r+em.r)){
          em.taken = true;
          world.emberCount += 1;
          world.runTime = Math.max(0, world.runTime - em.timeBonus);
          updateEmbersUI();
          showToast(`‚ú® Ember collected! -${em.timeBonus.toFixed(0)}s`, 900);
        }
      }

      if(dist2(b.x,b.y, world.goal.x, world.goal.y) <= (b.r + world.goal.r*0.70) ** 2){
        completeLevel();
      }
    }

    updateTimeUI();
  }

  function render(){
    ctx.clearRect(0,0,cv.width,cv.height);

    // ‚úÖ Background image (covers edges of canvas, slightly transparent)
    drawCoverImage(bgImages[world.bgIndex], BG_ALPHA);

    // Keep your subtle ‚Äúpanel‚Äù feel on top
    const grd = ctx.createLinearGradient(0,0,0,cv.height);
    grd.addColorStop(0, "rgba(255,180,0,0.10)");
    grd.addColorStop(1, "rgba(0,0,0,0.20)");
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,cv.width,cv.height);

    ctx.globalAlpha = 0.12;
    for(let i=0;i<90;i++){
      const x = (i*73 % cv.width);
      const y = (i*41 % cv.height);
      ctx.beginPath();
      ctx.arc(x,y, (i%7)+1, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.28)";
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // ‚úÖ Shelves/platforms color depends on current background
    const shelfStroke = SHELF_COLORS[world.bgIndex] || "rgba(255,255,255,0.18)";
    drawSegments(world.solids, shelfStroke);

    drawChalk(world.chalk);
    drawStart();
    drawForge();
    drawEmbers();
    drawBall();
  }

  function drawSegments(segments, stroke){
    ctx.lineCap = "round";
    for(const s of segments){
      ctx.lineWidth = s.thick;
      ctx.strokeStyle = stroke;
      ctx.beginPath();
      ctx.moveTo(s.ax, s.ay);
      ctx.lineTo(s.bx, s.by);
      ctx.stroke();

      // darker edge
      ctx.lineWidth = Math.max(2, s.thick*0.25);
      ctx.strokeStyle = "rgba(0,0,0,0.28)";
      ctx.beginPath();
      ctx.moveTo(s.ax, s.ay);
      ctx.lineTo(s.bx, s.by);
      ctx.stroke();
    }
  }

  function drawChalk(segments){
    ctx.lineCap = "round";
    for(const s of segments){
      ctx.lineWidth = s.thick;
      ctx.strokeStyle = "rgba(255,255,255,0.88)";
      ctx.beginPath();
      ctx.moveTo(s.ax, s.ay);
      ctx.lineTo(s.bx, s.by);
      ctx.stroke();

      ctx.lineWidth = Math.max(2, s.thick*0.35);
      ctx.strokeStyle = "rgba(255,255,255,0.40)";
      ctx.beginPath();
      ctx.moveTo(s.ax + (Math.random()-0.5)*0.6, s.ay + (Math.random()-0.5)*0.6);
      ctx.lineTo(s.bx + (Math.random()-0.5)*0.6, s.by + (Math.random()-0.5)*0.6);
      ctx.stroke();

      ctx.lineWidth = Math.max(2, s.thick*0.18);
      ctx.strokeStyle = "rgba(0,0,0,0.12)";
      ctx.beginPath();
      ctx.moveTo(s.ax, s.ay);
      ctx.lineTo(s.bx, s.by);
      ctx.stroke();
    }
  }

  function drawStart(){
    const x = world.start.x, y = world.start.y, r = world.start.r;

    ctx.save();
    ctx.globalAlpha = 0.75;
    const glow = ctx.createRadialGradient(x,y, r*0.2, x,y, r*2.2);
    glow.addColorStop(0, "rgba(255,210,0,0.55)");
    glow.addColorStop(1, "rgba(255,210,0,0)");
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(x,y, r*2.2, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.beginPath();
    ctx.arc(x,y, r*1.05, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,205,30,0.95)";
    ctx.beginPath();
    ctx.arc(x,y, r*0.62, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.beginPath();
    ctx.arc(x - r*0.18, y - r*0.18, r*0.22, 0, Math.PI*2);
    ctx.fill();

    ctx.font = `900 ${Math.max(14, Math.round(cv.width*0.018))}px system-ui`;
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.textAlign = "center";
    ctx.fillText("CHAINSTONE", x, y - r*1.35);
  }

  function drawForge(){
    const x = world.goal.x, y = world.goal.y, r = world.goal.r;

    ctx.save();
    const glow = ctx.createRadialGradient(x,y, r*0.2, x,y, r*2.6);
    glow.addColorStop(0, "rgba(255,120,0,0.70)");
    glow.addColorStop(1, "rgba(255,120,0,0)");
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(x,y, r*2.6, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.beginPath();
    ctx.arc(x,y, r*1.05, Math.PI*0.05, Math.PI*0.95);
    ctx.lineTo(x+r*0.9, y+r*0.6);
    ctx.lineTo(x-r*0.9, y+r*0.6);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "rgba(255,150,0,0.85)";
    ctx.beginPath();
    ctx.arc(x,y+ r*0.12, r*0.72, Math.PI*0.1, Math.PI*0.9);
    ctx.fill();

    ctx.font = `950 ${Math.max(14, Math.round(cv.width*0.018))}px system-ui`;
    ctx.fillStyle = "rgba(255,210,120,0.96)";
    ctx.textAlign = "center";
    ctx.fillText("THE FORGE", x, y + r*1.55);
  }

  function drawEmbers(){
    for(const em of world.embers){
      if(em.taken) continue;

      const x = em.x, y = em.y, r = em.r;

      ctx.save();
      const g = ctx.createRadialGradient(x,y, r*0.3, x,y, r*2.2);
      g.addColorStop(0, "rgba(255,150,0,0.65)");
      g.addColorStop(1, "rgba(255,150,0,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x,y, r*2.2, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      ctx.fillStyle = "rgba(255,180,40,0.95)";
      ctx.beginPath();
      ctx.arc(x,y, r*0.65, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.beginPath();
      ctx.arc(x - r*0.18, y - r*0.18, r*0.18, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawBall(){
    const b = world.ball;

    ctx.fillStyle = "rgba(0,0,0,0.28)";
    ctx.beginPath();
    ctx.ellipse(b.x, b.y + b.r*0.65, b.r*0.9, b.r*0.45, 0, 0, Math.PI*2);
    ctx.fill();

    const g = ctx.createRadialGradient(b.x - b.r*0.35, b.y - b.r*0.35, b.r*0.2, b.x, b.y, b.r*1.2);
    g.addColorStop(0, "rgba(255,220,90,0.98)");
    g.addColorStop(1, "rgba(255,140,0,0.95)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.beginPath();
    ctx.arc(b.x - b.r*0.25, b.y - b.r*0.25, b.r*0.28, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = "rgba(0,0,0,0.18)";
    ctx.lineWidth = Math.max(2, b.r*0.12);
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.stroke();
  }

  function updateInkUI(){
    const pct = (world.ink / world.inkMax) * 100;
    inkLeftEl.textContent = Math.round(pct);
    inkFill.style.width = `${pct}%`;
    inkFill.style.opacity = pct < 10 ? "0.35" : "1";
  }
  function updateTimeUI(){
    runTimeEl.textContent = world.runTime.toFixed(1);
    totalTimeEl.textContent = world.totalTime.toFixed(1);
  }
  function updateEmbersUI(){
    embersEl.textContent = world.emberCount;
  }

  // ============================================================
  // COMPLETE + STARS
  // ============================================================

  function computeStars(lv, time){
    const [t3, t2, t1] = lv.starTimes;
    if(time <= t3) return 3;
    if(time <= t2) return 2;
    if(time <= t1) return 1;
    return 0;
  }

  function openModal(stars, msg){
    modalStars.textContent = "‚≠ê".repeat(stars) + "‚òÜ".repeat(Math.max(0, 3-stars));
    modalBody.textContent = msg;
    modal.style.display = "flex";
  }
  function closeModal(){ modal.style.display = "none"; }

  function completeLevel(){
    if(world.completed) return;
    world.completed = true;
    world.rolling = false;

    world.totalTime += world.runTime;

    const lv = levelsByDiff[currentDifficulty][currentLevelIndex];
    const stars = computeStars(lv, world.runTime);

    modalTitle.textContent = `Level ${currentLevelIndex+1} Complete!`;
    const emberTaken = world.embers.filter(e=>e.taken).length;
    const msg =
`Run Time: ${world.runTime.toFixed(1)}s  ‚Ä¢  Embers: ${emberTaken}/${world.embers.length}
Total Time: ${world.totalTime.toFixed(1)}s`;
    openModal(stars, msg);

    btnRetry.disabled = false;
    btnStart.disabled = true;
    showToast("üèÅ Forged! Next level unlocked.", 1300);
  }

  // ============================================================
  // BUTTONS
  // ============================================================

  btnArcade.addEventListener("click", () => {
    window.location.href = "arcade.html";
  });

  btnLeaderboard.addEventListener("click", () => {
    openLeaderboard("");
  });

  lbClose.addEventListener("click", () => { lbModal.style.display = "none"; });
  lbModal.addEventListener("click", (e) => { if(e.target === lbModal) lbModal.style.display = "none"; });

  btnClear.addEventListener("click", () => {
    world.chalk = [];
    world.ink = world.inkMax;
    world.drawingLocked = false;

    const lv = levelsByDiff[currentDifficulty][currentLevelIndex];
    const s = px(lv.start);
    world.ball.x = s[0];
    world.ball.y = s[1] - world.ball.r*0.2;
    world.ball.vx = 0; world.ball.vy = 0;
    world.ball.released = false;
    world.ball.alive = true;

    world.runTime = 0;
    world.rolling = false;
    world.completed = false;
    world.emberCount = 0;
    world.embers.forEach(e=>e.taken=false);

    stopTimer = 0;
    groundTimer = 0;

    btnStart.disabled = false;
    btnRetry.disabled = true;

    updateInkUI(); updateTimeUI(); updateEmbersUI(); updateLivesUI();
    showToast("Cleared. Draw again ‚úçÔ∏è", 1000);
  });

  btnStart.addEventListener("click", () => {
    if(world.completed) return;
    if(world.lives <= 0) return;

    world.drawingLocked = true;
    world.ball.released = true;
    world.rolling = true;

    // reset timers at start
    stopTimer = 0;
    groundTimer = 0;

    world.ball.vx += 40;

    btnRetry.disabled = false;
    btnStart.disabled = true;

    showToast("GO! üü† Roll to the Forge!", 1100);
  });

  btnRetry.addEventListener("click", () => {
    world.lives = world.livesMax;
    world.inkMax = inkMaxByDiff[currentDifficulty] ?? world.inkMax;
    updateLivesUI();
    loadLevel(currentDifficulty, currentLevelIndex);
  });

  difficultySelect.addEventListener("change", (e) => {
    setDifficulty(e.target.value);
  });

  btnNext.addEventListener("click", () => {
    closeModal();
    const list = levelsByDiff[currentDifficulty];
    if(currentLevelIndex < list.length - 1){
      currentLevelIndex++;
      loadLevel(currentDifficulty, currentLevelIndex);
    } else {
      showToast("üéâ All levels complete!", 1400);
      currentLevelIndex = 0;
      loadLevel(currentDifficulty, currentLevelIndex);
    }
  });

  btnClose.addEventListener("click", () => closeModal());
  modal.addEventListener("click", (e) => { if(e.target === modal) closeModal(); });

  // ============================================================
  // INIT
  // ============================================================

  resizeCanvasToFit();

  // Start on Ember (dropdown default)
  difficultySelect.value = currentDifficulty;
  world.inkMax = inkMaxByDiff[currentDifficulty];
  world.livesMax = livesByDiff[currentDifficulty];
  world.lives = world.livesMax;
  updateLivesUI();

  // start bg at -1 so first loadLevel() sets it to 0 (bg1)
  world.bgIndex = -1;

  loadLevel(currentDifficulty, currentLevelIndex);

  function loop(ts){
    const dt = Math.min(0.033, (ts - lastTs) / 1000);
    lastTs = ts;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>

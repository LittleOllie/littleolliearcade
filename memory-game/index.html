<!DOCTYPE html>
<html lang="en">
<head>

<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  base-uri 'self';
  object-src 'none';
  frame-ancestors 'none';
  img-src 'self' data:;
  style-src 'self' 'unsafe-inline';
  script-src 'self' https://www.gstatic.com https://www.googleapis.com 'unsafe-inline';
  connect-src 'self' https://firestore.googleapis.com https://www.googleapis.com;
  upgrade-insecure-requests;
">
<meta http-equiv="Referrer-Policy" content="no-referrer">
<meta http-equiv="X-Content-Type-Options" content="nosniff">
<meta http-equiv="X-Frame-Options" content="DENY">

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Little Ollie Memory Game</title>

<style>
* { box-sizing: border-box; }

body {
  margin: 0;
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  background: radial-gradient(circle at top, #6de0ff, #4c6fff);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  color: #fff;
}

.game-wrapper {
  background: rgba(0,0,0,0.18);
  border-radius: 20px;
  padding: 16px;
  box-shadow: 0 12px 28px rgba(0,0,0,0.35);
  width: 960px;
  max-width: 96vw;
}

.header-image {
  width: 100%;
  margin-bottom: 10px;
  display: block;
}

.stats {
  font-size: 15px;
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 8px;
}

.controls {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-bottom: 12px;
  align-items: center;
}

/* âœ… All buttons = same yellow */
button,
.btn,
.overlay-box button {
  padding: 8px 16px;
  border-radius: 10px;
  border: none;
  cursor: pointer;
  background: #ffdd55;
  color: #222;
  font-weight: 900;
}

button:active,
.btn:active,
.overlay-box button:active { transform: translateY(1px); }

button:disabled,
.btn:disabled,
.overlay-box button:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

/* âœ… Make dropdowns yellow too */
select {
  padding: 10px 12px;
  border-radius: 12px;
  border: none;
  outline: none;
  font-weight: 900;
  background: #ffdd55;
  color: #222;
}

/* Inputs */
input{
  padding: 10px 12px;
  border-radius: 12px;
  border: none;
  outline:none;
}

/* Board */
.game-board {
  display: grid;
  gap: 10px;
}

/* Card */
.card {
  aspect-ratio: 1 / 1;
  perspective: 800px;
  cursor: pointer;
  transition: transform 0.45s cubic-bezier(.22,.61,.36,1);
  will-change: transform;
}

.card-inner {
  width: 100%;
  height: 100%;
  transition: transform 0.35s ease;
  transform-style: preserve-3d;
}

.card.flipped .card-inner,
.card.matched .card-inner {
  transform: rotateY(180deg);
}

.card-face {
  position: absolute;
  inset: 0;
  border-radius: 12px;
  backface-visibility: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
  background: #fff;
  border: 3px solid #111;
}

.card-back img { max-width: 80%; }
.card-front { transform: rotateY(180deg); }
.card-front img { max-width: 90%; }

.card.matched .card-front {
  background: #d1fae5;
  border-color: #10b981;
}

/* Wiggle */
@keyframes wiggle {
  0% { transform: translate(0,0) rotate(0); }
  25% { transform: translate(2px,-2px) rotate(-2deg); }
  50% { transform: translate(-2px,2px) rotate(2deg); }
  75% { transform: translate(1px,-1px) rotate(-1deg); }
  100% { transform: translate(0,0) rotate(0); }
}
.card.wiggle { animation: wiggle 0.35s ease; }

/* Overlay */
.overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 20;
}

.overlay-box {
  background: rgba(255,255,255,.18);
  backdrop-filter: blur(12px);
  border-radius: 20px;
  padding: 24px;
  text-align: center;
  box-shadow: 0 20px 50px rgba(0,0,0,.5);
  width: min(560px, 92vw);
}

hr {
  border: none;
  border-top: 1px solid rgba(255,255,255,.25);
  margin: 14px 0;
}

/* Confetti */
.confetti {
  position: fixed;
  top: -10px;
  width: 10px;
  height: 14px;
  animation: fall linear forwards;
  z-index: 50;
}
@keyframes fall {
  to { transform: translateY(110vh) rotate(360deg); }
}

/* Leaderboard */
.leaderboard {
  text-align: left;
  margin-top: 10px;
  background: rgba(0,0,0,0.15);
  padding: 12px;
  border-radius: 14px;
}

.lb-title {
  display:flex;
  justify-content: space-between;
  align-items:center;
  gap: 10px;
  flex-wrap: wrap;
}

.lb-title h3 { margin: 0; font-size: 16px; }

.lb-status { font-size: 12px; opacity: 0.9; }

.lb-list {
  margin: 10px 0 0;
  padding: 0;
  list-style: none;
  display: grid;
  gap: 6px;
}

.lb-row {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  background: rgba(255,255,255,0.12);
  padding: 8px 10px;
  border-radius: 10px;
  font-size: 14px;
  border: 1px solid rgba(255,255,255,0.12);
}

/* âœ… Podium shading (1st/2nd/3rd) */
.lb-row.rank-1 {
  background: rgba(255, 215, 0, 0.22);
  border: 1px solid rgba(255, 215, 0, 0.35);
}
.lb-row.rank-2 {
  background: rgba(192, 192, 192, 0.22);
  border: 1px solid rgba(192, 192, 192, 0.35);
}
.lb-row.rank-3 {
  background: rgba(205, 127, 50, 0.22);
  border: 1px solid rgba(205, 127, 50, 0.35);
}

.lb-divider {
  height: 1px;
  background: rgba(255,255,255,0.22);
  margin: 10px 0 6px;
  border-radius: 999px;
}

.lb-name { font-weight: 900; }
.lb-meta { opacity: 0.95; }

.name-row {
  display:flex;
  gap: 8px;
  justify-content:center;
  align-items:center;
  flex-wrap: wrap;
  margin-top: 10px;
}

.name-row input {
  padding: 10px 12px;
  border-radius: 12px;
  border: none;
  width: min(260px, 80vw);
  outline: none;
}

/* Fun bits */
.badge-row{
  display:flex;
  justify-content:center;
  gap:8px;
  flex-wrap: wrap;
  margin-top: 8px;
  font-size: 13px;
  opacity: 0.95;
}
.badge {
  background: rgba(0,0,0,0.18);
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.14);
}

.toast{
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: 18px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  padding: 10px 14px;
  border-radius: 999px;
  font-weight: 900;
  z-index: 60;
  display:none;
  max-width: 92vw;
  text-align:center;
}

/* Player overlay styling bits */
.player-hint{
  opacity: .92;
  font-weight: 800;
  line-height: 1.35;
  margin-top: 10px;
}
.player-row{
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:center;
  flex-wrap:wrap;
  margin-top: 12px;
}
.player-row input{
  width: min(320px, 84vw);
}
.smallnote{
  opacity:.9;
  font-size: 12px;
  font-weight: 800;
  margin-top: 8px;
}
</style>
</head>

<body>

<!-- âœ… PLAYER GATE OVERLAY -->
<div class="overlay" id="playerOverlay" style="display:none;">
  <div class="overlay-box">
    <h2>ğŸ‘¤ Choose your player name</h2>

    <div class="player-row">
      <input id="playerGateInput" maxlength="20" placeholder="Enter a username (1â€“20 chars)" />
      <button id="savePlayerBtn">âœ… Save Name</button>
    </div>

    <div class="player-row" style="margin-top:8px;">
      <button id="continueAnonBtn">ğŸ˜¶ Continue as Anon</button>
      <button id="clearPlayerBtn" title="Forget saved name">ğŸ§¹ Clear</button>
    </div>

    <div class="player-hint">
      If you play as <b>Anon</b> you can still enjoy the game, but you <b>canâ€™t submit scores</b>.
    </div>
    <div class="smallnote">
      (No password. Name saves on this device.)
    </div>

    <hr />
    <button id="playerOverlayOkBtn">â–¶ï¸ Continue</button>
  </div>
</div>

<!-- WIN -->
<div class="overlay" id="winOverlay" style="display:none">
  <div class="overlay-box">
    <h2>ğŸ‰ You Win! ğŸ‰</h2>
    <p id="winStats"></p>

    <div class="badge-row">
      <span class="badge" id="rankBadge">Rank: â€”</span>
      <span class="badge" id="dailyBadge">Daily: â€”</span>
      <span class="badge" id="streakBadge">Streak: â€”</span>
    </div>

    <div class="name-row">
      <input id="playerName" placeholder="âœï¸ Enter your name (optional)" maxlength="20" />
      <button class="btn" id="submitScoreBtn">ğŸ“¤ Submit Score</button>
    </div>

    <div class="leaderboard" id="winLeaderboardBox">
      <div class="lb-title">
        <h3>ğŸ† Leaderboard (<span id="lbDiff">easy</span>)</h3>
        <div class="lb-status" id="lbStatus">Loadingâ€¦</div>
      </div>

      <div class="lb-divider" id="podiumDivider" style="display:none;"></div>
      <ol class="lb-list" id="lbList"></ol>
    </div>

    <hr />

    <button class="btn" id="openLbBtn">ğŸ“‹ Open Leaderboards</button>
    <button class="btn" onclick="location.reload()">ğŸ” Play Again</button>
  </div>
</div>

<!-- LEADERBOARD SCREEN -->
<div class="overlay" id="leaderboardOverlay" style="display:none">
  <div class="overlay-box" style="text-align:left;">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;">
      <h2 style="margin:0;">ğŸ† Leaderboards</h2>
      <button id="closeLbOverlayBtn">â†©ï¸ Return to game</button>
    </div>

    <div class="controls" style="margin-top:12px;">
      <label style="font-weight:900;">ğŸšï¸ Difficulty:</label>
      <select id="lbSelect">
        <option value="easy">ğŸ˜Š Easy</option>
        <option value="medium">ğŸ˜ Medium</option>
        <option value="hard">ğŸ”¥ Hard</option>
        <option value="extra-hard">â˜ ï¸ Extra Hard</option>
      </select>
    </div>

    <div class="leaderboard" style="margin-top:12px;">
      <div class="lb-title">
        <h3 style="margin:0;">ğŸ Top 10 (<span id="lbDiff2">easy</span>)</h3>
        <div class="lb-status" id="lbStatus2">Loadingâ€¦</div>
      </div>
      <div class="lb-divider" id="podiumDivider2" style="display:none;"></div>
      <ol class="lb-list" id="lbList2"></ol>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<div class="game-wrapper">
  <img src="header.png" class="header-image" alt="Header" />

  <div class="stats">
    <div>Moves: <span id="moves">0</span></div>
    <div>Matches: <span id="matches">0</span>/<span id="total">0</span></div>
    <div>Time: <span id="time">0</span>s</div>
  </div>

  <div class="controls">
    <button class="btn" id="backMenuBtn">ğŸ•¹ï¸ Arcade Menu</button>

    <!-- âœ… Start + Difficulty in the main controls -->
    <button class="btn" id="startBtn">â–¶ï¸ Start</button>

    <select id="diffSelect" title="Difficulty">
      <option value="easy">ğŸšï¸ Difficulty: ğŸ˜Š Easy (12)</option>
      <option value="medium">ğŸšï¸ Difficulty: ğŸ˜ Medium (20)</option>
      <option value="hard">ğŸšï¸ Difficulty: ğŸ”¥ Hard (30)</option>
      <option value="extra-hard">ğŸšï¸ Difficulty: â˜ ï¸ Extra Hard (42)</option>
    </select>

    <button class="btn" id="restartBtn">ğŸ” Restart</button>
    <button class="btn" id="leaderboardsBtn">ğŸ† Leaderboards</button>

    <!-- keep your extras exactly as you had them -->
    <button class="btn" id="soundBtn">ğŸ”Š My stupid voice: ON</button>
    <button class="btn" id="hintBtn">ğŸ’¡ Hint (1)</button>
    <button class="btn" id="shareBtn" style="display:none;">ğŸ“£ Share</button>
  </div>

  <div class="game-board" id="board"></div>
</div>

<script type="module">
/* =========================
   FIREBASE (Firestore)
   ========================= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
import {
  getFirestore,
  collection,
  addDoc,
  serverTimestamp,
  query,
  where,
  orderBy,
  limit,
  onSnapshot,
  getDocs
} from "https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyCpoXdJ1ASWEhp9IM4hm_LeVOW0VFqQ2hg",
  authDomain: "little-ollie-memory.firebaseapp.com",
  projectId: "little-ollie-memory",
  storageBucket: "little-ollie-memory.firebasestorage.app",
  messagingSenderId: "846792708520",
  appId: "1:846792708520:web:851cf20bf6a80754cd8d9d",
  measurementId: "G-CJCEBPSS2M"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* =========================
   PLAYER (localStorage)
   ========================= */
const LS_PLAYER_NAME = "lo_player_name_v1";
const LS_PLAYER_ID   = "lo_player_id_v1";

/* tiny id helper */
function makeId(){
  if (crypto?.randomUUID) return crypto.randomUUID();
  return "p_" + Date.now() + "_" + Math.random().toString(16).slice(2);
}

function getPlayer(){
  const name = (localStorage.getItem(LS_PLAYER_NAME) || "").trim();
  let id = (localStorage.getItem(LS_PLAYER_ID) || "").trim();
  if (!id) {
    id = makeId();
    localStorage.setItem(LS_PLAYER_ID, id);
  }
  return { name, id, isAnon: !name };
}

function setPlayerName(name){
  const clean = (name || "").trim().slice(0, 20);
  if (clean) localStorage.setItem(LS_PLAYER_NAME, clean);
  else localStorage.removeItem(LS_PLAYER_NAME);
}

function clearPlayer(){
  localStorage.removeItem(LS_PLAYER_NAME);
  // keep id so you still track device if you want
}

/* Player overlay DOM */
const playerOverlay = document.getElementById("playerOverlay");
const playerGateInput = document.getElementById("playerGateInput");
const savePlayerBtn = document.getElementById("savePlayerBtn");
const continueAnonBtn = document.getElementById("continueAnonBtn");
const clearPlayerBtn = document.getElementById("clearPlayerBtn");
const playerOverlayOkBtn = document.getElementById("playerOverlayOkBtn");

/* =========================
   GAME
   ========================= */
const isMobile = window.matchMedia("(max-width: 768px)").matches;

const ALL_IMAGES = [...Array(100)].map((_, i) => `${i + 1}.png`);

const DIFFS = {
  easy:         { pairs: 6,  cols: isMobile ? 3 : 4 },
  medium:       { pairs: 10, cols: isMobile ? 4 : 5 },
  hard:         { pairs: 15, cols: isMobile ? 5 : 6 },
  "extra-hard": { pairs: 21, cols: isMobile ? 6 : 7 }
};

let currentDiff = "easy";

/* AUDIO */
let soundEnabled = true;

const flipSound = new Audio("flip.wav");
const correctSounds = ["tick1.wav","tick2.wav","tick3.wav","tick4.wav","tick5.wav"].map(f => new Audio(f));
const wrongSounds = ["wrong1.wav","wrong2.wav","wrong3.wav","wrong4.wav","wrong5.wav"].map(f => new Audio(f));

[flipSound, ...correctSounds, ...wrongSounds].forEach(s => s.volume = 0.75);

function play(sound){
  if (!soundEnabled) return;
  try { sound.currentTime = 0; sound.play(); } catch {}
}
function playFlip(){ play(flipSound); }
function playCorrect(){ play(correctSounds[Math.floor(Math.random() * correctSounds.length)]); }
function playWrong(){ play(wrongSounds[Math.floor(Math.random() * wrongSounds.length)]); }

/* DOM */
const board = document.getElementById("board");
const winOverlay = document.getElementById("winOverlay");
const leaderboardOverlay = document.getElementById("leaderboardOverlay");

const winStats = document.getElementById("winStats");
const movesEl = document.getElementById("moves");
const matchesEl = document.getElementById("matches");
const totalEl = document.getElementById("total");
const timeEl = document.getElementById("time");
const restartBtn = document.getElementById("restartBtn");
const soundBtn = document.getElementById("soundBtn");

const hintBtn = document.getElementById("hintBtn");
const leaderboardsBtn = document.getElementById("leaderboardsBtn");
const shareBtn = document.getElementById("shareBtn");

const playerNameEl = document.getElementById("playerName");
const submitScoreBtn = document.getElementById("submitScoreBtn");

const lbDiffEl = document.getElementById("lbDiff");
const lbStatusEl = document.getElementById("lbStatus");
const lbListEl = document.getElementById("lbList");
const podiumDivider = document.getElementById("podiumDivider");
const winLeaderboardBox = document.getElementById("winLeaderboardBox");

const openLbBtn = document.getElementById("openLbBtn");

const closeLbOverlayBtn = document.getElementById("closeLbOverlayBtn");
const lbSelect = document.getElementById("lbSelect");
const lbDiff2 = document.getElementById("lbDiff2");
const lbStatus2 = document.getElementById("lbStatus2");
const lbList2 = document.getElementById("lbList2");
const podiumDivider2 = document.getElementById("podiumDivider2");

const toastEl = document.getElementById("toast");

/* âœ… Start + difficulty controls */
const startBtn = document.getElementById("startBtn");
const diffSelect = document.getElementById("diffSelect");

/* Back to Arcade Menu */
const backMenuBtn = document.getElementById("backMenuBtn");
backMenuBtn.onclick = () => location.href = "../index.html";

/* FUN UI bits */
const rankBadge = document.getElementById("rankBadge");
const dailyBadge = document.getElementById("dailyBadge");
const streakBadge = document.getElementById("streakBadge");

/* STATE */
let cards = [];
let flipped = [];
let lock = true;
let moves = 0;
let matches = 0;
let totalPairs = 0;
let seconds = 0;
let timer = null;

let leaderboardUnsub = null;
let leaderboardUnsub2 = null;

let lastWin = null;

/* per-win submit lock */
let gameStartMs = Date.now();
let submittedThisWin = false;

/* hint */
let hintUsed = false;

/* âœ… game started flag (so Start only works when idle) */
let gameStarted = false;

/* daily + streak */
const STORAGE_KEYS = {
  streak: "lo_mem_streak_v1",
  lastWinDay: "lo_mem_last_win_day_v1",
  submittedWins: "lo_mem_submitted_wins_v1"
};

/* UTILS */
const shuffle = (a) => {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
};

function todayKey(){
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${yyyy}-${mm}-${dd}`;
}

function toast(msg){
  toastEl.textContent = msg;
  toastEl.style.display = "block";
  clearTimeout(toastEl._t);
  toastEl._t = setTimeout(() => toastEl.style.display = "none", 1400);
}

function setStartUi(isStarted){
  startBtn.disabled = isStarted;
  diffSelect.disabled = isStarted;
}

function resetStats(){
  cards = [];
  flipped = [];
  lock = true;
  moves = 0;
  matches = 0;
  seconds = 0;
  hintUsed = false;
  hintBtn.disabled = false;
  hintBtn.textContent = "ğŸ’¡ Hint (1)";
  shareBtn.style.display = "none";

  movesEl.textContent = "0";
  matchesEl.textContent = "0";
  timeEl.textContent = "0";
  if (timer) clearInterval(timer);
  timer = null;

  gameStartMs = Date.now();
  submittedThisWin = false;
  submitScoreBtn.disabled = false;
  submitScoreBtn.textContent = "ğŸ“¤ Submit Score";

  // âœ… keep idle until Start pressed
  gameStarted = false;
  setStartUi(false);
}

function startTimer(){
  if (timer) clearInterval(timer);
  timer = setInterval(() => {
    seconds++;
    timeEl.textContent = seconds;
  }, 1000);
}

function launchConfetti(count = 120){
  const total = Math.max(60, Math.min(160, count));
  for (let i = 0; i < total; i++) {
    const c = document.createElement("div");
    c.className = "confetti";
    c.style.left = Math.random() * 100 + "vw";
    c.style.background = `hsl(${Math.random() * 360},90%,60%)`;
    c.style.animationDuration = (2 + Math.random() * 3) + "s";
    document.body.appendChild(c);
    setTimeout(() => c.remove(), 5000);
  }
}

/* random image selection */
function buildOrderedPairs(totalPairs){
  const picked = shuffle([...ALL_IMAGES]).slice(0, totalPairs);

  picked.sort((a,b) => {
    const na = parseInt(a, 10);
    const nb = parseInt(b, 10);
    return na - nb;
  });

  const paired = [];
  for (const img of picked) paired.push(img, img);
  return paired;
}

/* âœ… NEW: render a visible idle board (easy by default) */
function renderIdleBoard(diffKey = "easy"){
  currentDiff = diffKey;
  diffSelect.value = currentDiff;

  const cfg = DIFFS[diffKey];
  if (!cfg) return;

  // reset counters + keep game locked (no timer, no clicks)
  resetStats();
  lock = true;
  gameStarted = false;
  setStartUi(false);

  totalPairs = cfg.pairs;
  totalEl.textContent = totalPairs;
  board.style.gridTemplateColumns = `repeat(${cfg.cols}, 1fr)`;

  // build a simple face-down board so something is visible
  const paired = buildOrderedPairs(totalPairs);
  cards = paired.map((img, i) => ({ id: i, img }));

  board.innerHTML = "";
  cards.forEach((c) => {
    const d = document.createElement("div");
    d.className = "card";
    d.dataset.id = c.id;
    d.innerHTML = `
      <div class="card-inner">
        <div class="card-face card-back"><img src="logo.png" alt="Logo"></div>
        <div class="card-face card-front"><img src="${c.img}" alt="Card"></div>
      </div>`;
    board.appendChild(d);
  });

  winOverlay.style.display = "none";
  leaderboardOverlay.style.display = "none";
}

/* âœ… Optional tracking: log a "play" when the game starts */
async function logPlay(diffKey){
  try{
    const p = getPlayer();
    // If you want only named players tracked, uncomment:
    // if (p.isAnon) return;

    await addDoc(collection(db, "plays"), {
      playerId: p.id,
      name: p.name || "Anon",
      named: !p.isAnon,
      game: "memory",
      difficulty: diffKey,
      createdAt: serverTimestamp()
    });
  }catch(e){
    // silent â€” don't break gameplay
    console.warn("play log failed:", e?.code || e);
  }
}

function startGame(diffKey){
  currentDiff = diffKey;
  resetStats();

  winOverlay.style.display = "none";
  leaderboardOverlay.style.display = "none";

  const cfg = DIFFS[diffKey];
  if (!cfg) { alert("Difficulty key not found: " + diffKey); return; }

  // âœ… log a play when someone starts a run
  logPlay(diffKey);

  totalPairs = cfg.pairs;
  totalEl.textContent = totalPairs;
  board.style.gridTemplateColumns = `repeat(${cfg.cols}, 1fr)`;

  const paired = buildOrderedPairs(totalPairs);
  cards = paired.map((img, i) => ({ id: i, img }));

  board.innerHTML = "";
  cards.forEach((c) => {
    const d = document.createElement("div");
    d.className = "card";
    d.dataset.id = c.id;
    d.innerHTML = `
      <div class="card-inner">
        <div class="card-face card-back"><img src="logo.png" alt="Logo"></div>
        <div class="card-face card-front"><img src="${c.img}" alt="Card"></div>
      </div>`;
    board.appendChild(d);
  });

  // âœ… mark started + lock Start/Difficulty
  gameStarted = true;
  setStartUi(true);

  previewThenMix();
}

async function previewThenMix(){
  const els = [...document.querySelectorAll(".card")];

  els.forEach(c => { c.classList.add("flipped"); c.classList.add("wiggle"); });
  await new Promise(r => setTimeout(r, 380));
  els.forEach(c => c.classList.remove("wiggle"));

  await new Promise(r => setTimeout(r, 1200));

  els.forEach(c => c.classList.remove("flipped"));
  await new Promise(r => setTimeout(r, 350));

  els.forEach(c => c.classList.add("wiggle"));
  await new Promise(r => setTimeout(r, 350));
  els.forEach(c => c.classList.remove("wiggle"));

  await visualMixAndRemap(els);

  lock = false;
  startTimer();
}

async function visualMixAndRemap(els){
  const firstRects = new Map();
  els.forEach(el => firstRects.set(el, el.getBoundingClientRect()));

  const shuffledEls = shuffle([...els]);
  shuffledEls.forEach(el => board.appendChild(el));

  shuffledEls.forEach(el => {
    const last = el.getBoundingClientRect();
    const first = firstRects.get(el);
    el.style.transform = `translate(${first.left - last.left}px, ${first.top - last.top}px)`;
  });

  board.offsetHeight;

  shuffledEls.forEach(el => {
    el.style.transition = "transform 420ms cubic-bezier(.22,.61,.36,1)";
    el.style.transform = "";
  });

  await new Promise(r => setTimeout(r, 450));
  shuffledEls.forEach(el => el.style.transition = "");

  const imgs = cards.map(c => c.img);
  shuffle(imgs);

  shuffledEls.forEach((tileEl) => {
    const id = +tileEl.dataset.id;
    const newImg = imgs[id];
    cards[id].img = newImg;
    tileEl.querySelector(".card-front img").src = newImg;
  });
}

/* ONE-TILE HINT (once per game) */
async function doOneTileHint(){
  if (hintUsed || lock) return;
  const els = [...document.querySelectorAll(".card")];
  const candidates = els.filter(el => !el.classList.contains("matched") && !el.classList.contains("flipped"));
  if (!candidates.length) return;

  hintUsed = true;
  hintBtn.disabled = true;
  hintBtn.textContent = "âœ… Hint used";
  lock = true;

  const pick = candidates[Math.floor(Math.random() * candidates.length)];
  pick.classList.add("flipped");
  playFlip();

  await new Promise(r => setTimeout(r, 650));
  pick.classList.remove("flipped");
  await new Promise(r => setTimeout(r, 150));

  lock = false;
}

/* GAME CLICK */
board.addEventListener("click", (e) => {
  const cardEl = e.target.closest(".card");
  if (!cardEl || lock || cardEl.classList.contains("matched")) return;

  const id = +cardEl.dataset.id;
  if (flipped.some(f => f.id === id)) return;

  cardEl.classList.add("flipped");
  playFlip();
  flipped.push({ id, img: cards[id].img, el: cardEl });

  if (flipped.length === 2) {
    lock = true;
    moves++;
    movesEl.textContent = moves;

    const [a, b] = flipped;

    if (a.img === b.img) {
      playCorrect();
      a.el.classList.add("matched");
      b.el.classList.add("matched");
      matches++;
      matchesEl.textContent = matches;
      flipped = [];
      lock = false;

      if (matches === totalPairs) {
        clearInterval(timer);

        launchConfetti(110);

        winStats.textContent = `ğŸ§  ${moves} moves Â· â±ï¸ ${seconds}s`;
        winOverlay.style.display = "flex";

        lastWin = { moves, time: seconds, diff: currentDiff, gameStartMs };
        lbDiffEl.textContent = currentDiff;

        shareBtn.style.display = "inline-block";

        updateStreakBadges();
        startLeaderboardListener(currentDiff, "win");
        updateRankAndCelebrate();

        // âœ… Auto-fill name + lock submit if anon
        syncPlayerToWinInput();
        applySubmitRulesForPlayer();
      }
    } else {
      playWrong();
      setTimeout(() => {
        a.el.classList.remove("flipped");
        b.el.classList.remove("flipped");
        flipped = [];
        lock = false;
      }, 850);
    }
  }
});

restartBtn.onclick = () => location.reload();

soundBtn.onclick = () => {
  soundEnabled = !soundEnabled;
  soundBtn.textContent = `ğŸ”Š My stupid voice: ${soundEnabled ? "ON" : "OFF"}`;
};

hintBtn.onclick = () => doOneTileHint();

/* âœ… Start + Difficulty handlers */
diffSelect.value = currentDiff;
diffSelect.addEventListener("change", () => {
  currentDiff = diffSelect.value;

  // âœ… If not started yet, update the preview board to match
  if (!gameStarted) {
    renderIdleBoard(currentDiff);
  } else {
    toast(`Difficulty set: ${currentDiff}`);
  }
});

startBtn.addEventListener("click", () => {
  if (gameStarted) return;
  startGame(currentDiff);
});

/* LEADERBOARD SCREEN */
function openLeaderboardOverlay(initialDiff = currentDiff){
  leaderboardOverlay.style.display = "flex";
  lbSelect.value = initialDiff;
  lbDiff2.textContent = initialDiff;
  startLeaderboardListener(initialDiff, "screen");
}
function closeLeaderboardOverlay(){
  leaderboardOverlay.style.display = "none";
}

leaderboardsBtn.onclick = () => openLeaderboardOverlay(currentDiff);
openLbBtn.onclick = () => openLeaderboardOverlay(currentDiff);
closeLbOverlayBtn.onclick = () => closeLeaderboardOverlay();

lbSelect.addEventListener("change", () => {
  lbDiff2.textContent = lbSelect.value;
  startLeaderboardListener(lbSelect.value, "screen");
});

/* Share */
shareBtn.onclick = async () => {
  if (!lastWin) return;
  const url = location.href;
  const text = `I just scored ${lastWin.moves} moves in ${lastWin.time}s on Little Ollie Memory (${lastWin.diff})! ğŸ§ âœ¨`;
  try{
    if (navigator.share){
      await navigator.share({ title: "Little Ollie Memory Game", text, url });
    } else {
      await navigator.clipboard.writeText(`${text}\n${url}`);
      toast("âœ… Copied share text");
    }
  } catch {}
};

/* LEADERBOARD */
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[m]));
}

function medalForRank(i){
  if (i === 0) return "ğŸ¥‡ ";
  if (i === 1) return "ğŸ¥ˆ ";
  if (i === 2) return "ğŸ¥‰ ";
  return "";
}

function rankClass(i){
  if (i === 0) return " rank-1";
  if (i === 1) return " rank-2";
  if (i === 2) return " rank-3";
  return "";
}

function renderLeaderboardInto(items, listEl, statusEl, dividerEl){
  listEl.innerHTML = "";

  if (!items.length){
    if (dividerEl) dividerEl.style.display = "none";
    listEl.innerHTML = `<li class="lb-row"><span class="lb-name">No scores yet</span><span class="lb-meta"></span></li>`;
    statusEl.textContent = "No scores yet";
    return;
  }

  if (dividerEl) dividerEl.style.display = items.length >= 4 ? "block" : "none";

  items.forEach((it, idx) => {
    const name = it.name || "Anonymous";
    const meta = `${it.moves} moves Â· ${it.time}s`;

    const li = document.createElement("li");
    li.className = "lb-row" + rankClass(idx);
    li.innerHTML = `
      <span class="lb-name">${medalForRank(idx)}#${idx + 1} ${escapeHtml(name)}</span>
      <span class="lb-meta">${meta}</span>
    `;
    listEl.appendChild(li);

    if (idx === 2 && items.length > 3){
      const sep = document.createElement("div");
      sep.className = "lb-divider";
      listEl.appendChild(sep);
    }
  });

  statusEl.textContent = `Top ${items.length} shown`;
}

function startLeaderboardListener(diff, context){
  const isWin = context === "win";

  const listEl   = isWin ? lbListEl   : lbList2;
  const statusEl = isWin ? lbStatusEl : lbStatus2;
  const dividerEl= isWin ? podiumDivider : podiumDivider2;

  if (isWin){
    if (leaderboardUnsub) leaderboardUnsub();
  } else {
    if (leaderboardUnsub2) leaderboardUnsub2();
  }

  statusEl.textContent = "Loadingâ€¦";

  const primaryQuery = query(
    collection(db, "scores"),
    where("difficulty", "==", diff),
    orderBy("moves", "asc"),
    orderBy("time", "asc"),
    limit(10)
  );

  const fallbackQuery = query(
    collection(db, "scores"),
    orderBy("moves", "asc"),
    orderBy("time", "asc"),
    limit(200)
  );

  const attach = (q, isFallback = false) => {
    const unsub = onSnapshot(
      q,
      (snap) => {
        let items = snap.docs.map(d => d.data());

        if (isFallback){
          items = items.filter(it => it.difficulty === diff).slice(0, 10);
        }

        renderLeaderboardInto(items, listEl, statusEl, dividerEl);

        if (isFallback){
          statusEl.textContent = `Top ${items.length} shown (fallback mode)`;
        }
      },
      (err) => {
        console.error("Leaderboard error:", err);

        const code = err?.code || "";
        const msg  = err?.message || "";

        statusEl.textContent = `Leaderboard error: ${code} ${msg}`.trim();

        if (!isFallback && (code === "failed-precondition" || code === "permission-denied")){
          statusEl.textContent = `Leaderboard issue (${code}). Trying fallbackâ€¦`;
          const unsub2 = attach(fallbackQuery, true);
          if (isWin) leaderboardUnsub = unsub2;
          else leaderboardUnsub2 = unsub2;
        }
      }
    );

    return unsub;
  };

  const unsub = attach(primaryQuery, false);

  if (isWin) leaderboardUnsub = unsub;
  else leaderboardUnsub2 = unsub;
}

/* ANTI-SPAM: local only */
function getWinId(win){
  return `${win.diff}|${win.moves}|${win.time}|${win.gameStartMs}`;
}

function loadSubmittedWins(){
  try { return JSON.parse(localStorage.getItem(STORAGE_KEYS.submittedWins) || "[]"); }
  catch { return []; }
}
function saveSubmittedWins(arr){
  try { localStorage.setItem(STORAGE_KEYS.submittedWins, JSON.stringify(arr.slice(-50))); } catch {}
}
function isSubmittedAlready(winId){
  const arr = loadSubmittedWins();
  return arr.includes(winId);
}
function markSubmitted(winId){
  const arr = loadSubmittedWins();
  if (!arr.includes(winId)) arr.push(winId);
  saveSubmittedWins(arr);
}

function scrollToWinLeaderboard(){
  try { winLeaderboardBox.scrollIntoView({ behavior: "smooth", block: "start" }); } catch {}
}

/* âœ… Player -> win input */
function syncPlayerToWinInput(){
  const p = getPlayer();
  if (!p.isAnon) {
    playerNameEl.value = p.name;
  }
}

/* âœ… If anon: block submissions */
function applySubmitRulesForPlayer(){
  const p = getPlayer();
  if (p.isAnon) {
    submitScoreBtn.disabled = true;
    submitScoreBtn.textContent = "ğŸš« Set name to submit";
    toast("Anon mode: no score submissions");
  } else {
    if (!submittedThisWin) {
      submitScoreBtn.disabled = false;
      submitScoreBtn.textContent = "ğŸ“¤ Submit Score";
    }
  }
}

submitScoreBtn.addEventListener("click", async () => {
  const p = getPlayer();
  if (p.isAnon){
    alert("Anon canâ€™t submit scores. Go back and set a name ğŸ‘¤");
    return;
  }

  if (!lastWin) return;

  if (submittedThisWin){
    toast("âœ… Already submitted");
    scrollToWinLeaderboard();
    return;
  }

  const winId = getWinId(lastWin);

  if (isSubmittedAlready(winId)){
    submitScoreBtn.disabled = true;
    submitScoreBtn.textContent = "âœ… Submitted";
    toast("âœ… Already submitted");
    submittedThisWin = true;
    scrollToWinLeaderboard();
    return;
  }

  const rawName = (playerNameEl.value || "").trim();
  const name = rawName.slice(0, 20) || p.name || "Anonymous";

  submitScoreBtn.disabled = true;
  submitScoreBtn.textContent = "â³ Submittingâ€¦";

  try {
    await addDoc(collection(db, "scores"), {
      name,
      difficulty: lastWin.diff,
      moves: lastWin.moves,
      time: lastWin.time,
      winId,
      createdAt: serverTimestamp()
    });

    markSubmitted(winId);
    submittedThisWin = true;

    submitScoreBtn.textContent = "âœ… Submitted";
    toast("ğŸ† Score added!");
    startLeaderboardListener(lastWin.diff, "win");
    updateRankAndCelebrate();
    scrollToWinLeaderboard();

  } catch (err) {
    console.error("Submit score error:", err);
    alert(`Could not submit score:\n${err.code || ""}\n${err.message || ""}`);
    submitScoreBtn.textContent = "ğŸ“¤ Submit Score";
    submitScoreBtn.disabled = false;
  }
});

/* FUN: daily + streak + rank */
function updateStreakBadges(){
  const day = todayKey();
  const lastDay = localStorage.getItem(STORAGE_KEYS.lastWinDay) || "";
  let streak = parseInt(localStorage.getItem(STORAGE_KEYS.streak) || "0", 10);

  if (lastDay !== day){
    const d = new Date(day + "T00:00:00");
    const y = new Date(d.getTime() - 86400000);
    const yKey = `${y.getFullYear()}-${String(y.getMonth()+1).padStart(2,"0")}-${String(y.getDate()).padStart(2,"0")}`;

    if (lastDay === yKey) streak += 1;
    else streak = 1;

    localStorage.setItem(STORAGE_KEYS.lastWinDay, day);
    localStorage.setItem(STORAGE_KEYS.streak, String(streak));
  }

  dailyBadge.textContent = `ğŸ“… Daily: ${day}`;
  streakBadge.textContent = `ğŸ”¥ Streak: ${streak}`;
}

async function updateRankAndCelebrate(){
  if (!lastWin) return;

  rankBadge.textContent = "Rank: â€”";

  try{
    const q = query(
      collection(db, "scores"),
      where("difficulty", "==", lastWin.diff),
      orderBy("moves", "asc"),
      orderBy("time", "asc"),
      limit(10)
    );
    const snap = await getDocs(q);
    const items = snap.docs.map(d => d.data());

    let idx = items.findIndex(it => it.moves === lastWin.moves && it.time === lastWin.time);

    if (idx >= 0){
      const rankNum = idx + 1;
      const emoji = rankNum === 1 ? "ğŸ¥‡" : rankNum === 2 ? "ğŸ¥ˆ" : rankNum === 3 ? "ğŸ¥‰" : "ğŸ";
      rankBadge.textContent = `ğŸ… Rank: ${emoji} #${rankNum}`;

      if (rankNum === 1){
        launchConfetti(160);
        toast("ğŸ¥‡ NEW #1!");
      }
    } else {
      rankBadge.textContent = "ğŸ Rank: (not in top 10 yet)";
    }
  } catch {
    // keep â€”
  }
}

/* =========================
   PLAYER OVERLAY FLOW (INIT)
   ========================= */
function showPlayerOverlayIfNeeded(){
  const p = getPlayer();

  // If a name already exists, skip overlay
  if (!p.isAnon) {
    playerOverlay.style.display = "none";
    return;
  }

  // else show overlay first
  playerOverlay.style.display = "flex";
}

function proceedToGameUi(){
  playerOverlay.style.display = "none";
}

savePlayerBtn.addEventListener("click", () => {
  const name = (playerGateInput.value || "").trim();
  if (name.length < 1 || name.length > 20){
    alert("Name must be 1â€“20 characters.");
    return;
  }
  setPlayerName(name);
  toast(`Saved: ${name}`);
});

continueAnonBtn.addEventListener("click", () => {
  toast("Continuing as Anon");
});

clearPlayerBtn.addEventListener("click", () => {
  clearPlayer();
  playerGateInput.value = "";
  toast("Cleared saved name");
});

playerOverlayOkBtn.addEventListener("click", () => {
  const typed = (playerGateInput.value || "").trim();
  if (typed) setPlayerName(typed.slice(0,20));
  proceedToGameUi();
});

/* On load */
(function initPlayer(){
  const p = getPlayer();
  if (!p.isAnon) playerGateInput.value = p.name;
  showPlayerOverlayIfNeeded();

  // âœ… show easy cards immediately (idle preview)
  renderIdleBoard("easy");
})();
</script>
</body>
</html>

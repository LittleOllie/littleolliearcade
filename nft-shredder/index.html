<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Rugged NFT Shredder</title>
  <style>
    *{ box-sizing:border-box; }
    :root{
      --bg1:#6de0ff;
      --bg2:#4c6fff;
      --panel: rgba(0,0,0,.18);
      --panel2: rgba(0,0,0,.22);
      --shadow: 0 16px 40px rgba(0,0,0,.35);
      --text:#fff;
      --yellow:#ffdd55;
      --yellow2:#ffd22e;
      --red:#ff4b4b;
      --green:#48e07a;
      --radius:18px;
    }

    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
      background: radial-gradient(1200px 800px at 30% 20%, rgba(255,255,255,.22), transparent 55%),
                  linear-gradient(135deg, var(--bg1), var(--bg2));
      overflow:hidden;
    }

    .wrap{
      width:min(980px, 96vw);
      border-radius:24px;
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,.18);
      overflow:hidden;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:14px 16px;
      background: linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,.12));
      border-bottom: 1px solid rgba(255,255,255,.14);
    }

    .title{
      display:flex;
      flex-direction:column;
      line-height:1.05;
    }
    .title b{
      font-size:18px;
      letter-spacing:.3px;
    }
    .title span{
      font-size:12px;
      opacity:.9;
    }

    .btnRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    button, .fileBtn{
      border:none;
      cursor:pointer;
      border-radius: 14px;
      padding:10px 12px;
      font-weight:800;
      letter-spacing:.2px;
      box-shadow: 0 10px 18px rgba(0,0,0,.22);
      transition: transform .08s ease, filter .12s ease;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    button:active, .fileBtn:active{ transform: translateY(1px) scale(.99); }

    .primary{
      background: linear-gradient(180deg, var(--yellow), var(--yellow2));
      color:#1f1f1f;
    }
    .danger{
      background: linear-gradient(180deg, #ff6b6b, #ff3d3d);
      color:#fff;
    }
    .ghost{
      background: rgba(0,0,0,.22);
      color:#fff;
      border: 1px solid rgba(255,255,255,.18);
      box-shadow:none;
    }

    input[type="file"]{ display:none; }
    .fileBtn{
      background: rgba(0,0,0,.22);
      color:#fff;
      border: 1px solid rgba(255,255,255,.18);
      box-shadow:none;
    }

    .main{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
      padding:14px;
    }

    @media (max-width: 860px){
      .main{ grid-template-columns: 1fr; }
    }

    .card{
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,.14));
      border: 1px solid rgba(255,255,255,.14);
      overflow:hidden;
    }

    .screen{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    canvas{
      width:100%;
      height:auto;
      display:block;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
    }

    .dropZone{
      padding:12px;
      border-radius: 14px;
      border: 2px dashed rgba(255,255,255,.24);
      background: rgba(0,0,0,.12);
      text-align:center;
      font-weight:800;
      line-height:1.25;
    }
    .dropZone small{
      display:block;
      margin-top:6px;
      font-weight:600;
      opacity:.9;
    }

    .side{
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .stat{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.12);
      font-weight:800;
    }
    .stat span{ opacity:.95; font-weight:700; }

    .log{
      flex:1;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.12);
      font-size:13px;
      line-height:1.35;
      overflow:auto;
    }

    .tag{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.12);
      border:1px solid rgba(255,255,255,.18);
      font-size:12px;
      font-weight:900;
      letter-spacing:.2px;
    }

    .foot{
      padding:12px 14px;
      text-align:center;
      font-weight:900;
      opacity:.92;
      border-top:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.12);
    }
  </style>

<link rel="stylesheet" href="../ui/lo-arcade-kit.css">
<script defer src="../ui/lo-arcade-kit.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <b>Rugged NFT Shredder üßªü™ì</b>
        <span>Drop an image ‚Üí watch it get *cartoon shredded*</span>
      </div>

      <div class="btnRow">
        <label class="fileBtn" for="fileIn">üì• Upload Image</label>
        <input id="fileIn" type="file" accept="image/*" />
        <button id="shredBtn" class="danger">üß® SHRED IT</button>
        <button id="resetBtn" class="ghost">‚ôªÔ∏è Reset</button>
      </div>
    </div>

    <div class="main">
      <div class="card screen">
        <div id="dropZone" class="dropZone">
          DROP YOUR RUGGED NFT IMAGE HERE üò≠
          <small>(or click ‚ÄúUpload Image‚Äù)</small>
        </div>
        <canvas id="c" width="900" height="560"></canvas>
      </div>

      <div class="card side">
        <div class="stat">
          <div>State</div>
          <span id="stateTxt">Waiting for image‚Ä¶</span>
        </div>
        <div class="stat">
          <div>Shreds</div>
          <span id="shredCount">0</span>
        </div>
        <div class="stat">
          <div>Vibe</div>
          <span class="tag">üòà funny cartoon</span>
        </div>
        <div class="log" id="log">
          <b>How to play</b><br>
          1) Drop an image in the box.<br>
          2) Smash <b>SHRED IT</b>.<br>
          3) Laugh. Heal. Move on. ü´∂<br><br>
          <span style="opacity:.9">Tip: Use screenshots of your ‚Äúrugged‚Äù art for best results.</span>
        </div>
      </div>
    </div>

    <div class="foot">Little Ollie Arcade ‚Ä¢ ‚ÄúTherapy, but shredded.‚Äù</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const fileIn = document.getElementById('fileIn');
  const dropZone = document.getElementById('dropZone');
  const shredBtn = document.getElementById('shredBtn');
  const resetBtn = document.getElementById('resetBtn');

  const stateTxt = document.getElementById('stateTxt');
  const shredCountEl = document.getElementById('shredCount');
  const log = document.getElementById('log');

  // --- Game state
  const S = {
    mode: 'idle', // idle | ready | pulling | shredding | done
    img: null,
    imgW: 0,
    imgH: 0,
    paper: { x: 0, y: 60, w: 360, h: 360, yOffset: 0 },
    shredder: { x: 0, y: 0, w: 520, h: 220, slotY: 0 },
    strips: [],
    confetti: [],
    shreds: 0,
    t: 0,
  };

  function setState(text){
    stateTxt.textContent = text;
  }
  function addLog(html){
    log.innerHTML = html + "<hr style='border:none;border-top:1px solid rgba(255,255,255,.12);margin:10px 0;'>" + log.innerHTML;
  }
  function resizeLayout(){
    // Keep fixed canvas size but compute layout positions based on canvas
    const W = canvas.width, H = canvas.height;

    S.paper.w = Math.min(420, Math.floor(W * 0.45));
    S.paper.h = S.paper.w;
    S.paper.x = Math.floor(W * 0.12);
    S.paper.y = Math.floor(H * 0.10);

    S.shredder.w = Math.min(560, Math.floor(W * 0.62));
    S.shredder.h = Math.floor(S.shredder.w * 0.42);
    S.shredder.x = Math.floor((W - S.shredder.w) / 2);
    S.shredder.y = Math.floor(H * 0.60);

    S.shredder.slotY = S.shredder.y + Math.floor(S.shredder.h * 0.18);
  }

  // --- Drawing helpers (thick outline cartoon style)
  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function outlineFill(fill, stroke='rgba(0,0,0,.9)', lw=6){
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.lineWidth = lw;
    ctx.strokeStyle = stroke;
    ctx.stroke();
  }

  function drawBackground(){
    const W = canvas.width, H = canvas.height;

    // subtle stars/specks
    ctx.clearRect(0,0,W,H);
    ctx.save();
    ctx.globalAlpha = 0.20;
    for(let i=0;i<28;i++){
      const x = (i*97 + S.t*4) % W;
      const y = (i*53 + 80) % H;
      ctx.beginPath();
      ctx.arc(x, y, 2.2, 0, Math.PI*2);
      ctx.fillStyle = '#fff';
      ctx.fill();
    }
    ctx.restore();

    // floor
    ctx.save();
    ctx.globalAlpha = 0.18;
    roundRect(40, H-120, W-80, 95, 22);
    outlineFill('rgba(0,0,0,.20)', 'rgba(255,255,255,.22)', 2.5);
    ctx.restore();
  }

  function drawPaper(){
    const p = S.paper;
    const x = p.x, y = p.y + p.yOffset;
    const w = p.w, h = p.h;

    // shadow
    ctx.save();
    ctx.globalAlpha = 0.25;
    roundRect(x+10, y+14, w, h, 22);
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.fill();
    ctx.restore();

    // paper
    roundRect(x, y, w, h, 22);
    outlineFill('rgba(255,255,255,.92)');

    // "rug pulled" stamp when done
    if(S.mode === 'done'){
      ctx.save();
      ctx.translate(x + w*0.12, y + h*0.56);
      ctx.rotate(-0.22);
      ctx.globalAlpha = 0.95;
      roundRect(0,0, w*0.76, h*0.22, 14);
      outlineFill('rgba(255,75,75,.92)');
      ctx.fillStyle = '#fff';
      ctx.font = `900 ${Math.floor(h*0.12)}px ui-sans-serif`;
      ctx.fillText('RUG PULLED', Math.floor(w*0.08), Math.floor(h*0.155));
      ctx.restore();
    }

    // draw image inside paper
    if(S.img){
      const pad = 18;
      const ix = x + pad, iy = y + pad;
      const iw = w - pad*2, ih = h - pad*2;

      // fit image
      const ar = S.imgW / S.imgH;
      let dw = iw, dh = dw / ar;
      if(dh > ih){ dh = ih; dw = dh * ar; }
      const dx = ix + (iw - dw)/2;
      const dy = iy + (ih - dh)/2;

      // clip
      ctx.save();
      roundRect(x+10, y+10, w-20, h-20, 18);
      ctx.clip();

      // if shredding, draw only top portion (like it‚Äôs being eaten)
      if(S.mode === 'pulling' || S.mode === 'shredding'){
        // mask bottom being "taken"
        const eaten = Math.max(0, (S.shredder.slotY - (y + h)) + 10);
        // eaten isn't perfect; use yOffset to simulate pull
        ctx.drawImage(S.img, dx, dy, dw, dh);
        // add wiggly "tear" line
        ctx.globalAlpha = 0.9;
        ctx.lineWidth = 6;
        ctx.strokeStyle = 'rgba(0,0,0,.85)';
        ctx.beginPath();
        const tearY = y + h - 18;
        for(let i=0;i<=10;i++){
          const tx = x + 18 + (w-36)*(i/10);
          const ty = tearY + Math.sin((S.t*0.18)+(i*0.9))*3;
          if(i===0) ctx.moveTo(tx, ty);
          else ctx.lineTo(tx, ty);
        }
        ctx.stroke();
      } else if(S.mode === 'done'){
        // nothing (it got shredded)
        ctx.globalAlpha = 0.0;
      } else {
        ctx.drawImage(S.img, dx, dy, dw, dh);
      }

      ctx.restore();
    } else {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.55)';
      ctx.font = '900 22px ui-sans-serif';
      ctx.fillText('DROP IMAGE HERE', x + 32, y + h/2 - 8);
      ctx.font = '800 14px ui-sans-serif';
      ctx.fillText('Your rugged NFT gets shredded üò≠', x + 32, y + h/2 + 16);
      ctx.restore();
    }
  }

  function drawShredder(){
    const sh = S.shredder;
    const x = sh.x, y = sh.y, w = sh.w, h = sh.h;

    // body shadow
    ctx.save();
    ctx.globalAlpha = 0.22;
    roundRect(x+12, y+16, w, h, 26);
    ctx.fillStyle = 'rgba(0,0,0,.45)';
    ctx.fill();
    ctx.restore();

    // body
    roundRect(x, y, w, h, 26);
    outlineFill('rgba(30,30,40,.86)');

    // fun face panel
    const faceX = x + w*0.06, faceY = y + h*0.42, faceW = w*0.30, faceH = h*0.45;
    roundRect(faceX, faceY, faceW, faceH, 18);
    outlineFill('rgba(255,255,255,.14)', 'rgba(0,0,0,.9)', 5);

    // eyes
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,.9)';
    ctx.strokeStyle = 'rgba(0,0,0,.9)';
    ctx.lineWidth = 5;
    const ex1 = faceX + faceW*0.34, ex2 = faceX + faceW*0.70;
    const ey = faceY + faceH*0.42;
    ctx.beginPath(); ctx.arc(ex1, ey, faceW*0.09, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.arc(ex2, ey, faceW*0.09, 0, Math.PI*2); ctx.fill(); ctx.stroke();

    // pupils wiggle
    ctx.fillStyle = 'rgba(0,0,0,.92)';
    const wig = Math.sin(S.t*0.12)*2;
    ctx.beginPath(); ctx.arc(ex1+wig, ey+1, faceW*0.04, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(ex2+wig, ey+1, faceW*0.04, 0, Math.PI*2); ctx.fill();

    // mouth
    ctx.strokeStyle = 'rgba(255,75,75,.95)';
    ctx.lineWidth = 7;
    ctx.beginPath();
    ctx.arc(faceX + faceW*0.52, faceY + faceH*0.70, faceW*0.16, 0.1, Math.PI-0.1);
    ctx.stroke();
    ctx.restore();

    // slot
    const slotX = x + w*0.18, slotW = w*0.64, slotH = h*0.12;
    const slotY = sh.slotY;

    roundRect(slotX, slotY, slotW, slotH, 16);
    outlineFill('rgba(0,0,0,.62)', 'rgba(0,0,0,.92)', 6);

    // teeth
    ctx.save();
    ctx.globalAlpha = 0.95;
    const teethCount = 16;
    const tpad = 10;
    const tw = (slotW - tpad*2) / teethCount;
    for(let i=0;i<teethCount;i++){
      const tx = slotX + tpad + i*tw;
      const ty = slotY + slotH*0.25;
      roundRect(tx, ty, tw*0.78, slotH*0.50, 8);
      outlineFill('rgba(255,255,255,.78)', 'rgba(0,0,0,.85)', 4);
    }
    ctx.restore();

    // "WARNING: RUGS" label
    ctx.save();
    ctx.translate(x + w*0.62, y + h*0.58);
    ctx.rotate(-0.06);
    roundRect(-w*0.18, -h*0.12, w*0.36, h*0.22, 16);
    outlineFill('rgba(255,221,85,.92)');
    ctx.fillStyle = 'rgba(0,0,0,.86)';
    ctx.font = `900 ${Math.floor(h*0.10)}px ui-sans-serif`;
    ctx.fillText('NO RUGS', -w*0.11, Math.floor(h*0.04));
    ctx.restore();
  }

  function spawnStrips(){
    // Create strips from the paper image area
    const p = S.paper;
    const paperBottom = p.y + p.yOffset + p.h;
    const slotY = S.shredder.slotY + 8;

    const xCenter = p.x + p.w/2;
    const startY = Math.min(slotY, paperBottom - 12);

    const stripCount = 18;
    for(let i=0;i<stripCount;i++){
      const w = 10 + Math.random()*10;
      const h = 46 + Math.random()*42;
      S.strips.push({
        x: xCenter + (Math.random()-0.5)*(p.w*0.68),
        y: startY + Math.random()*6,
        w, h,
        vy: 3 + Math.random()*3,
        vx: (Math.random()-0.5)*1.2,
        rot: (Math.random()-0.5)*0.4,
        vr: (Math.random()-0.5)*0.06,
        life: 260 + Math.random()*120,
        ink: Math.random(),
      });
    }

    S.shreds += 1;
    shredCountEl.textContent = String(S.shreds);
  }

  function drawStrips(){
    for(const s of S.strips){
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(s.rot);

      // strip colors (cartoony)
      const shade = 0.85 + (s.ink*0.1);
      roundRect(-s.w/2, -s.h/2, s.w, s.h, 8);
      outlineFill(`rgba(255,255,255,${shade})`, 'rgba(0,0,0,.9)', 5);

      // little "ink" squiggles
      ctx.strokeStyle = 'rgba(0,0,0,.35)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-s.w*0.2, -s.h*0.15);
      ctx.lineTo(s.w*0.2, 0);
      ctx.lineTo(-s.w*0.1, s.h*0.15);
      ctx.stroke();

      ctx.restore();
    }
  }

  function spawnConfetti(){
    const W = canvas.width, H = canvas.height;
    for(let i=0;i<90;i++){
      S.confetti.push({
        x: Math.random()*W,
        y: -20 - Math.random()*H*0.2,
        vy: 2 + Math.random()*5,
        vx: (Math.random()-0.5)*2.0,
        r: 2 + Math.random()*4,
        rot: Math.random()*Math.PI,
        vr: (Math.random()-0.5)*0.2,
        life: 240 + Math.random()*120
      });
    }
  }
  function drawConfetti(){
    ctx.save();
    for(const c of S.confetti){
      ctx.translate(c.x, c.y);
      ctx.rotate(c.rot);
      ctx.beginPath();
      ctx.rect(-c.r, -c.r, c.r*2, c.r*2);
      ctx.fillStyle = 'rgba(255,255,255,.92)';
      ctx.fill();
      ctx.setTransform(1,0,0,1,0,0);
    }
    ctx.restore();
  }

  function update(){
    S.t++;

    // pull paper down into shredder
    if(S.mode === 'pulling'){
      S.paper.yOffset += 4.6;
      // once the bottom hits slot, begin shredding
      const bottom = S.paper.y + S.paper.yOffset + S.paper.h;
      if(bottom >= S.shredder.slotY + 8){
        S.mode = 'shredding';
        setState('Shredding‚Ä¶ üòà');
        addLog(`<b>CHOMP!</b> The shredder is hungry‚Ä¶ üßª`);
      }
    }

    // shredding: spawn strips repeatedly, paper continues down a bit then disappears
    if(S.mode === 'shredding'){
      // keep pulling
      S.paper.yOffset += 3.2;

      // spawn strips every few frames
      if(S.t % 10 === 0) spawnStrips();

      // finish after enough shreds
      if(S.shreds >= 7){
        S.mode = 'done';
        setState('Done. Rug = shredded ‚úÖ');
        spawnConfetti();
        addLog(`<b>RUG PULLED.</b> But you? You survived. ü´∂‚ú®`);
      }
    }

    // update strips
    for(const s of S.strips){
      s.x += s.vx;
      s.y += s.vy;
      s.rot += s.vr;
      s.life--;
      // tiny wobble
      s.vx += (Math.random()-0.5)*0.05;
      s.vx *= 0.995;
    }
    S.strips = S.strips.filter(s => s.life > 0 && s.y < canvas.height + 120);

    // update confetti
    for(const c of S.confetti){
      c.x += c.vx;
      c.y += c.vy;
      c.rot += c.vr;
      c.life--;
    }
    S.confetti = S.confetti.filter(c => c.life > 0 && c.y < canvas.height + 80);

    draw();
    requestAnimationFrame(update);
  }

  function draw(){
    resizeLayout();
    drawBackground();
    drawPaper();
    drawShredder();
    drawStrips();
    drawConfetti();
  }

  function reset(){
    S.mode = 'idle';
    S.img = null;
    S.imgW = S.imgH = 0;
    S.paper.yOffset = 0;
    S.strips = [];
    S.confetti = [];
    S.shreds = 0;
    shredCountEl.textContent = '0';
    setState('Waiting for image‚Ä¶');
    addLog(`<b>Reset</b> ‚Äî ready to shred again üßª`);
  }

  function readyWithImage(img){
    S.img = img;
    S.imgW = img.naturalWidth || img.width;
    S.imgH = img.naturalHeight || img.height;
    S.paper.yOffset = 0;
    S.strips = [];
    S.confetti = [];
    S.shreds = 0;
    shredCountEl.textContent = '0';
    S.mode = 'ready';
    setState('Loaded. Ready to shred.');
    addLog(`<b>Loaded!</b> That rug doesn‚Äôt stand a chance üòà`);
  }

  function loadFile(file){
    if(!file) return;
    if(!file.type || !file.type.startsWith('image/')){
      addLog(`<b>Oops:</b> Please upload an image file (PNG/JPG/WebP).`);
      return;
    }
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      URL.revokeObjectURL(url);
      readyWithImage(img);
    };
    img.src = url;
  }

  // --- UI events
  fileIn.addEventListener('change', (e) => loadFile(e.target.files && e.target.files[0]));

  shredBtn.addEventListener('click', () => {
    if(S.mode !== 'ready'){
      addLog(`<b>Need an image first</b> ‚Äî drop one in üò≠`);
      return;
    }
    S.mode = 'pulling';
    setState('Pulling into shredder‚Ä¶ üßª');
    addLog(`<b>SHRED MODE:</b> Activated üß®`);
  });

  resetBtn.addEventListener('click', reset);

  // drag & drop
  ;['dragenter','dragover'].forEach(ev => {
    dropZone.addEventListener(ev, (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.style.borderColor = 'rgba(255,221,85,.95)';
      dropZone.style.background = 'rgba(0,0,0,.18)';
    });
  });
  ;['dragleave','drop'].forEach(ev => {
    dropZone.addEventListener(ev, (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.style.borderColor = 'rgba(255,255,255,.24)';
      dropZone.style.background = 'rgba(0,0,0,.12)';
    });
  });

  dropZone.addEventListener('drop', (e) => {
    const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
    loadFile(file);
  });

  // start
  reset();
  update();
})();
</script>
</body>
</html>
